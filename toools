  ---                                                                                                                                                
  Parte 12: tools/index.ts (282 linhas)                                                                                                              
                                                                                                                                                     
  import { Tool, ToolRouter } from '../tool-router';                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPORTS                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  // Schedule Tools                                                                                                                                  
  export {                                                                                                                                           
    scheduleInquiryTool,                                                                                                                             
    scheduleInquiryInputSchema,                                                                                                                      
    type ScheduleInquiryInput,                                                                                                                       
  } from './schedule-inquiry.tool';                                                                                                                  
                                                                                                                                                     
  export {                                                                                                                                           
    scheduleConfirmationTool,                                                                                                                        
    scheduleConfirmationInputSchema,                                                                                                                 
    type ScheduleConfirmationInput,                                                                                                                  
  } from './schedule-confirmation.tool';                                                                                                             
                                                                                                                                                     
  // Payment Tools                                                                                                                                   
  export {                                                                                                                                           
    paymentLinkTool,                                                                                                                                 
    paymentLinkInputSchema,                                                                                                                          
    type PaymentLinkInput,                                                                                                                           
    checkPaymentStatusTool,                                                                                                                          
    checkPaymentStatusInputSchema,                                                                                                                   
    type CheckPaymentStatusInput,                                                                                                                    
    testAsaasConnectionTool,                                                                                                                         
    testAsaasConnectionInputSchema,                                                                                                                  
    type TestAsaasConnectionInput,                                                                                                                   
  } from './payment-link.tool';                                                                                                                      
                                                                                                                                                     
  // Handoff Tool                                                                                                                                    
  export {                                                                                                                                           
    humanHandoffTool,                                                                                                                                
    humanHandoffInputSchema,                                                                                                                         
    type HumanHandoffInput,                                                                                                                          
    DEPARTMENT_ID_MAP,                                                                                                                               
    DEPARTMENT_NAME_TO_ID,                                                                                                                           
  } from './human-handoff.tool';                                                                                                                     
                                                                                                                                                     
  // Lead Management Tools                                                                                                                           
  export {                                                                                                                                           
    updateLeadTool,                                                                                                                                  
    updateLeadInputSchema,                                                                                                                           
    type UpdateLeadInput,                                                                                                                            
    extractLeadInfoTool,                                                                                                                             
    extractLeadInfoInputSchema,                                                                                                                      
    type ExtractLeadInfoInput,                                                                                                                       
  } from './update-lead.tool';                                                                                                                       
                                                                                                                                                     
  // Timezone Detection Tool                                                                                                                         
  export {                                                                                                                                           
    detectTimezoneTool,                                                                                                                              
    detectTimezoneInputSchema,                                                                                                                       
    type DetectTimezoneInput,                                                                                                                        
  } from './detect-timezone.tool';                                                                                                                   
                                                                                                                                                     
  // Qualification Tool                                                                                                                              
  export {                                                                                                                                           
    qualifyLeadTool,                                                                                                                                 
    qualifyLeadInputSchema,                                                                                                                          
    type QualifyLeadInput,                                                                                                                           
  } from './qualify-lead.tool';                                                                                                                      
                                                                                                                                                     
  // No Interest / Finalize Tools                                                                                                                    
  export {                                                                                                                                           
    noInterestTool,                                                                                                                                  
    noInterestInputSchema,                                                                                                                           
    type NoInterestInput,                                                                                                                            
    finalizeAttendanceTool,                                                                                                                          
    finalizeAttendanceInputSchema,                                                                                                                   
    type FinalizeAttendanceInput,                                                                                                                    
  } from './no-interest.tool';                                                                                                                       
                                                                                                                                                     
  // Unified Intent Tool (Leadbox Format)                                                                                                            
  export {                                                                                                                                           
    processCustomerIntentTool,                                                                                                                       
    processCustomerIntentInputSchema,                                                                                                                
    type ProcessCustomerIntentInput,                                                                                                                 
    DEPARTMENT_IDS,                                                                                                                                  
    type DepartmentName,                                                                                                                             
    type DepartmentId,                                                                                                                               
  } from './process-customer-intent.tool';                                                                                                           
                                                                                                                                                     
  // Voice Message Tool                                                                                                                              
  export {                                                                                                                                           
    sendVoiceMessageTool,                                                                                                                            
    sendVoiceMessageInputSchema,                                                                                                                     
    type SendVoiceMessageInput,                                                                                                                      
  } from './send-voice-message.tool';                                                                                                                
                                                                                                                                                     
  // Location Tool                                                                                                                                   
  export {                                                                                                                                           
    sendLocationTool,                                                                                                                                
    sendLocationInputSchema,                                                                                                                         
    type SendLocationInput,                                                                                                                          
  } from './send-location.tool';                                                                                                                     
                                                                                                                                                     
  // Contact Tool                                                                                                                                    
  export {                                                                                                                                           
    sendContactTool,                                                                                                                                 
    sendContactInputSchema,                                                                                                                          
    type SendContactInput,                                                                                                                           
  } from './send-contact.tool';                                                                                                                      
                                                                                                                                                     
  // ============================================================================                                                                    
  // ALL TOOLS ARRAY                                                                                                                                 
  // ============================================================================                                                                    
                                                                                                                                                     
  /**                                                                                                                                                
   * Array com todas as tools disponíveis                                                                                                            
   */                                                                                                                                                
  export const allTools: Tool[] = [                                                                                                                  
    // Schedule                                                                                                                                      
    scheduleInquiryTool,                                                                                                                             
    scheduleConfirmationTool,                                                                                                                        
                                                                                                                                                     
    // Payment                                                                                                                                       
    paymentLinkTool,                                                                                                                                 
    checkPaymentStatusTool,                                                                                                                          
    testAsaasConnectionTool,                                                                                                                         
                                                                                                                                                     
    // Handoff                                                                                                                                       
    humanHandoffTool,                                                                                                                                
                                                                                                                                                     
    // Lead Management                                                                                                                               
    updateLeadTool,                                                                                                                                  
    extractLeadInfoTool,                                                                                                                             
    detectTimezoneTool,                                                                                                                              
                                                                                                                                                     
    // Qualification                                                                                                                                 
    qualifyLeadTool,                                                                                                                                 
                                                                                                                                                     
    // No Interest / Finalize                                                                                                                        
    noInterestTool,                                                                                                                                  
    finalizeAttendanceTool,                                                                                                                          
                                                                                                                                                     
    // Unified Intent (Leadbox Format)                                                                                                               
    processCustomerIntentTool,                                                                                                                       
                                                                                                                                                     
    // Voice                                                                                                                                         
    sendVoiceMessageTool,                                                                                                                            
                                                                                                                                                     
    // Location                                                                                                                                      
    sendLocationTool,                                                                                                                                
                                                                                                                                                     
    // Contact                                                                                                                                       
    sendContactTool,                                                                                                                                 
  ];                                                                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // REGISTER FUNCTION                                                                                                                               
  // ============================================================================                                                                    
                                                                                                                                                     
  /**                                                                                                                                                
   * Registra todas as tools no ToolRouter                                                                                                           
   */                                                                                                                                                
  export function registerAllTools(                                                                                                                  
    router: ToolRouter,                                                                                                                              
    options?: {                                                                                                                                      
      overwrite?: boolean;                                                                                                                           
      exclude?: string[];                                                                                                                            
      include?: string[];                                                                                                                            
    }                                                                                                                                                
  ): number {                                                                                                                                        
    const { overwrite = false, exclude = [], include } = options || {};                                                                              
                                                                                                                                                     
    let registered = 0;                                                                                                                              
                                                                                                                                                     
    for (const tool of allTools) {                                                                                                                   
      if (exclude.includes(tool.name)) {                                                                                                             
        continue;                                                                                                                                    
      }                                                                                                                                              
                                                                                                                                                     
      if (include && !include.includes(tool.name)) {                                                                                                 
        continue;                                                                                                                                    
      }                                                                                                                                              
                                                                                                                                                     
      if (router.has(tool.name) && !overwrite) {                                                                                                     
        console.warn(`[registerAllTools] Tool '${tool.name}' already exists, skipping`);                                                             
        continue;                                                                                                                                    
      }                                                                                                                                              
                                                                                                                                                     
      router.register(tool);                                                                                                                         
      registered++;                                                                                                                                  
    }                                                                                                                                                
                                                                                                                                                     
    console.log(`[registerAllTools] Registered ${registered} tools`);                                                                                
    return registered;                                                                                                                               
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL CATEGORIES                                                                                                                                 
  // ============================================================================                                                                    
                                                                                                                                                     
  export const toolsByCategory = {                                                                                                                   
    schedule: [scheduleInquiryTool, scheduleConfirmationTool],                                                                                       
    payment: [paymentLinkTool, checkPaymentStatusTool, testAsaasConnectionTool],                                                                     
    handoff: [humanHandoffTool],                                                                                                                     
    leadManagement: [updateLeadTool, extractLeadInfoTool, detectTimezoneTool],                                                                       
    qualification: [qualifyLeadTool],                                                                                                                
    closing: [noInterestTool, finalizeAttendanceTool],                                                                                               
    unified: [processCustomerIntentTool],                                                                                                            
    voice: [sendVoiceMessageTool],                                                                                                                   
    location: [sendLocationTool],                                                                                                                    
    contact: [sendContactTool],                                                                                                                      
  } as const;                                                                                                                                        
                                                                                                                                                     
  export function registerToolsByCategory(                                                                                                           
    router: ToolRouter,                                                                                                                              
    category: keyof typeof toolsByCategory                                                                                                           
  ): number {                                                                                                                                        
    const tools = toolsByCategory[category];                                                                                                         
    let registered = 0;                                                                                                                              
                                                                                                                                                     
    for (const tool of tools) {                                                                                                                      
      if (!router.has(tool.name)) {                                                                                                                  
        router.register(tool);                                                                                                                       
        registered++;                                                                                                                                
      }                                                                                                                                              
    }                                                                                                                                                
                                                                                                                                                     
    return registered;                                                                                                                               
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL NAMES MAP                                                                                                                                  
  // ============================================================================                                                                    
                                                                                                                                                     
  export const TOOL_REGISTRY = {                                                                                                                     
    SCHEDULE_INQUIRY: scheduleInquiryTool.name,                                                                                                      
    SCHEDULE_CONFIRMATION: scheduleConfirmationTool.name,                                                                                            
    PAYMENT_LINK: paymentLinkTool.name,                                                                                                              
    CHECK_PAYMENT_STATUS: checkPaymentStatusTool.name,                                                                                               
    TEST_ASAAS_CONNECTION: testAsaasConnectionTool.name,                                                                                             
    HUMAN_HANDOFF: humanHandoffTool.name,                                                                                                            
    UPDATE_LEAD: updateLeadTool.name,                                                                                                                
    EXTRACT_LEAD_INFO: extractLeadInfoTool.name,                                                                                                     
    DETECT_LEAD_TIMEZONE: detectTimezoneTool.name,                                                                                                   
    QUALIFY_LEAD: qualifyLeadTool.name,                                                                                                              
    NO_INTEREST: noInterestTool.name,                                                                                                                
    FINALIZE_ATTENDANCE: finalizeAttendanceTool.name,                                                                                                
    PROCESS_CUSTOMER_INTENT: processCustomerIntentTool.name,                                                                                         
    SEND_VOICE_MESSAGE: sendVoiceMessageTool.name,                                                                                                   
    SEND_LOCATION: sendLocationTool.name,                                                                                                            
    SEND_CONTACT: sendContactTool.name,                                                                                                              
  } as const;                                                                                                                                        
                                                                                                                                                     
  export type ToolName = keyof typeof TOOL_REGISTRY;                                                                                                 
  export type ToolCategory = keyof typeof toolsByCategory;                                                                                           
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 13: tools/schedule-inquiry.tool.ts (693 linhas)                                                                                              
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import {                                                                                                                                           
    GoogleCalendarClient,                                                                                                                            
    createGoogleCalendarClient,                                                                                                                      
    createMultiCalendarClientFromAccounts,                                                                                                           
    GoogleAccount,                                                                                                                                   
    AccountScheduleConfig,                                                                                                                           
    filterSlotsByPeriod,                                                                                                                             
    filterSlotsForAgent,                                                                                                                             
    TimeSlot,                                                                                                                                        
  } from '../../../services/calendar';                                                                                                               
  import { createHolidayCheckerFromTimezone, checkHoliday } from '../../../utils/holidays';                                                          
  import { leadsRepository } from '../../../services/supabase/repositories';                                                                         
  import {                                                                                                                                           
    convertCreatorTimeToLeadTime,                                                                                                                    
    getTimezoneFriendlyName,                                                                                                                         
    isSameTimezone,                                                                                                                                  
  } from '../../../utils/timezone';                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const scheduleInquiryInputSchema = z.object({                                                                                               
    date: z                                                                                                                                          
      .string()                                                                                                                                      
      .optional()                                                                                                                                    
      .describe('Data específica para consulta (YYYY-MM-DD). Se não fornecida, busca próximos 5 dias úteis.'),                                       
    duration: z                                                                                                                                      
      .number()                                                                                                                                      
      .optional()                                                                                                                                    
      .describe('Duração do slot em minutos. Se não fornecida, usa a duração configurada na agenda (default: 60).'),                                 
    daysAhead: z                                                                                                                                     
      .number()                                                                                                                                      
      .optional()                                                                                                                                    
      .default(5)                                                                                                                                    
      .describe('Quantos dias à frente buscar (default: 5)'),                                                                                        
  });                                                                                                                                                
                                                                                                                                                     
  export type ScheduleInquiryInput = z.infer<typeof scheduleInquiryInputSchema>;                                                                     
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPER FUNCTIONS                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  const DAY_NAME_TO_NUMBER: Record<string, number> = {                                                                                               
    sunday: 0,                                                                                                                                       
    monday: 1,                                                                                                                                       
    tuesday: 2,                                                                                                                                      
    wednesday: 3,                                                                                                                                    
    thursday: 4,                                                                                                                                     
    friday: 5,                                                                                                                                       
    saturday: 6,                                                                                                                                     
  };                                                                                                                                                 
                                                                                                                                                     
  function getNextBusinessDays(count: number, workDays?: string[], timezone?: string): string[] {                                                    
    const dates: string[] = [];                                                                                                                      
    const current = new Date();                                                                                                                      
    const holidayChecker = createHolidayCheckerFromTimezone(timezone);                                                                               
                                                                                                                                                     
    const allowedDays = new Set<number>();                                                                                                           
    if (workDays && workDays.length > 0) {                                                                                                           
      workDays.forEach((day) => {                                                                                                                    
        const dayNum = DAY_NAME_TO_NUMBER[day.toLowerCase()];                                                                                        
        if (dayNum !== undefined) {                                                                                                                  
          allowedDays.add(dayNum);                                                                                                                   
        }                                                                                                                                            
      });                                                                                                                                            
    } else {                                                                                                                                         
      [1, 2, 3, 4, 5].forEach((d) => allowedDays.add(d));                                                                                            
    }                                                                                                                                                
                                                                                                                                                     
    if (allowedDays.size === 0) {                                                                                                                    
      [1, 2, 3, 4, 5].forEach((d) => allowedDays.add(d));                                                                                            
    }                                                                                                                                                
                                                                                                                                                     
    let maxIterations = 60;                                                                                                                          
                                                                                                                                                     
    while (dates.length < count && maxIterations > 0) {                                                                                              
      current.setDate(current.getDate() + 1);                                                                                                        
      maxIterations--;                                                                                                                               
                                                                                                                                                     
      const dayOfWeek = current.getDay();                                                                                                            
      const dateStr = current.toISOString().split('T')[0];                                                                                           
                                                                                                                                                     
      if (!allowedDays.has(dayOfWeek)) {                                                                                                             
        continue;                                                                                                                                    
      }                                                                                                                                              
                                                                                                                                                     
      const holidayCheck = holidayChecker.isHoliday(dateStr);                                                                                        
      if (holidayCheck.isHoliday) {                                                                                                                  
        console.log(`[ScheduleInquiry] 🚫 Pulando feriado: ${dateStr} - ${holidayCheck.holiday?.name}`);                                             
        continue;                                                                                                                                    
      }                                                                                                                                              
                                                                                                                                                     
      dates.push(dateStr);                                                                                                                           
    }                                                                                                                                                
                                                                                                                                                     
    return dates;                                                                                                                                    
  }                                                                                                                                                  
                                                                                                                                                     
  function formatTimeSlot(isoString: string): string {                                                                                               
    const date = new Date(isoString);                                                                                                                
    return date.toLocaleTimeString('pt-BR', {                                                                                                        
      hour: '2-digit',                                                                                                                               
      minute: '2-digit',                                                                                                                             
      timeZone: 'America/Sao_Paulo',                                                                                                                 
    });                                                                                                                                              
  }                                                                                                                                                  
                                                                                                                                                     
  function formatDate(dateString: string): string {                                                                                                  
    const date = new Date(dateString + 'T12:00:00');                                                                                                 
    return date.toLocaleDateString('pt-BR', {                                                                                                        
      weekday: 'long',                                                                                                                               
      day: '2-digit',                                                                                                                                
      month: '2-digit',                                                                                                                              
      timeZone: 'America/Sao_Paulo',                                                                                                                 
    });                                                                                                                                              
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const scheduleInquiryTool: Tool = {                                                                                                         
    name: TOOL_NAMES.SCHEDULE_INQUIRY,                                                                                                               
    description: `Consulta horários disponíveis para agendamento de reuniões ou demonstrações.                                                       
  Use quando o cliente quiser:                                                                                                                       
  - Marcar uma reunião                                                                                                                               
  - Agendar uma demonstração                                                                                                                         
  - Ver horários disponíveis                                                                                                                         
  - Saber quando pode conversar                                                                                                                      
                                                                                                                                                     
  Retorna lista de slots disponíveis com data e horário.`,                                                                                           
                                                                                                                                                     
    inputSchema: scheduleInquiryInputSchema,                                                                                                         
                                                                                                                                                     
    requiresConfirmation: false,                                                                                                                     
    timeout: 15000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = scheduleInquiryInputSchema.safeParse(input);                                                                                    
                                                                                                                                                     
      if (!parsed.success) {                                                                                                                         
        return {                                                                                                                                     
          success: false,                                                                                                                            
          message: `Parâmetros inválidos: ${parsed.error.message}`,                                                                                  
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      }                                                                                                                                              
                                                                                                                                                     
      const { date, daysAhead } = parsed.data;                                                                                                       
      let { duration } = parsed.data;                                                                                                                
                                                                                                                                                     
      try {                                                                                                                                          
        const googleAccounts = context.integrations.google_accounts as GoogleAccount[] | null;                                                       
        const googleCredentials = context.integrations.google_credentials;                                                                           
        const googleCalendarId = context.integrations.google_calendar_id;                                                                            
                                                                                                                                                     
        const hasMultipleAccounts = googleAccounts && googleAccounts.length > 0;                                                                     
        const hasSingleAccount = googleCredentials && googleCredentials.refresh_token;                                                               
                                                                                                                                                     
        if (!hasMultipleAccounts && !hasSingleAccount) {                                                                                             
          return {                                                                                                                                   
            success: false,                                                                                                                          
            message: 'Integração com Google Calendar não configurada.',                                                                              
            nextAction: 'continue',                                                                                                                  
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        // Obter duração da reunião                                                                                                                  
        if (!duration) {                                                                                                                             
          if (googleAccounts && googleAccounts.length > 0) {                                                                                         
            const primaryAccount = googleAccounts[0] as any;                                                                                         
            duration = primaryAccount.meeting_duration;                                                                                              
          }                                                                                                                                          
          if (!duration) {                                                                                                                           
            duration = context.agentConfig.meeting_duration as number | undefined;                                                                   
          }                                                                                                                                          
          if (!duration) {                                                                                                                           
            duration = 60;                                                                                                                           
          }                                                                                                                                          
        }                                                                                                                                            
        const validDurations = [15, 30, 45, 60];                                                                                                     
        if (!validDurations.includes(duration)) {                                                                                                    
          duration = 60;                                                                                                                             
        }                                                                                                                                            
                                                                                                                                                     
        // Configuração de horário de trabalho                                                                                                       
        const businessHours = context.agentConfig.business_hours as { start?: string; end?: string } | null;                                         
        let workHoursStart: number;                                                                                                                  
        let workHoursEnd: number;                                                                                                                    
                                                                                                                                                     
        if (businessHours && businessHours.start) {                                                                                                  
          const parsedStart = parseInt(businessHours.start.split(':')[0], 10);                                                                       
          const parsedEnd = parseInt(businessHours.end?.split(':')[0] || '18', 10);                                                                  
          workHoursStart = !isNaN(parsedStart) ? parsedStart : 9;                                                                                    
          workHoursEnd = !isNaN(parsedEnd) ? parsedEnd : 18;                                                                                         
        } else {                                                                                                                                     
          workHoursStart = context.agentConfig.work_hours_start ?? 9;                                                                                
          workHoursEnd = context.agentConfig.work_hours_end ?? 18;                                                                                   
        }                                                                                                                                            
                                                                                                                                                     
        const workDays = context.agentConfig.work_days as string[] | null;                                                                           
        const agentTimezone = context.agentConfig.timezone as string || 'America/Sao_Paulo';                                                         
                                                                                                                                                     
        // Configuração de períodos (manhã/tarde)                                                                                                    
        const fullBusinessHours = context.agentConfig.business_hours as {                                                                            
          morning_enabled?: boolean;                                                                                                                 
          morning_start?: string;                                                                                                                    
          morning_end?: string;                                                                                                                      
          afternoon_enabled?: boolean;                                                                                                               
          afternoon_start?: string;                                                                                                                  
          afternoon_end?: string;                                                                                                                    
        } | null;                                                                                                                                    
                                                                                                                                                     
        let scheduleConfig: AccountScheduleConfig | null = null;                                                                                     
                                                                                                                                                     
        if (googleAccounts && googleAccounts.length > 0) {                                                                                           
          const primaryAccount = googleAccounts[0] as any;                                                                                           
          const hasMorningConfig = primaryAccount.morning_start || primaryAccount.morning_end;                                                       
          const hasAfternoonConfig = primaryAccount.afternoon_start || primaryAccount.afternoon_end;                                                 
                                                                                                                                                     
          const morningEnabled = primaryAccount.morning_enabled !== undefined                                                                        
            ? primaryAccount.morning_enabled === true                                                                                                
            : hasMorningConfig ? true : (fullBusinessHours?.morning_enabled !== false);                                                              
          const afternoonEnabled = primaryAccount.afternoon_enabled !== undefined                                                                    
            ? primaryAccount.afternoon_enabled === true                                                                                              
            : hasAfternoonConfig ? true : (fullBusinessHours?.afternoon_enabled !== false);                                                          
                                                                                                                                                     
          scheduleConfig = {                                                                                                                         
            morning_enabled: morningEnabled,                                                                                                         
            morning_start: primaryAccount.morning_start || fullBusinessHours?.morning_start || '08:00',                                              
            morning_end: primaryAccount.morning_end || fullBusinessHours?.morning_end || '12:00',                                                    
            afternoon_enabled: afternoonEnabled,                                                                                                     
            afternoon_start: primaryAccount.afternoon_start || fullBusinessHours?.afternoon_start || '14:00',                                        
            afternoon_end: primaryAccount.afternoon_end || fullBusinessHours?.afternoon_end || '18:00',                                              
            work_days: primaryAccount.work_days,                                                                                                     
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        // Determinar datas para consulta                                                                                                            
        let datesToCheck: string[];                                                                                                                  
        const dayMapping: Record<string, string> = {                                                                                                 
          seg: 'monday', ter: 'tuesday', qua: 'wednesday',                                                                                           
          qui: 'thursday', sex: 'friday', sab: 'saturday', dom: 'sunday',                                                                            
        };                                                                                                                                           
                                                                                                                                                     
        let effectiveWorkDays = workDays;                                                                                                            
                                                                                                                                                     
        if (scheduleConfig?.work_days) {                                                                                                             
          const accountWorkDays: string[] = [];                                                                                                      
          for (const [key, enabled] of Object.entries(scheduleConfig.work_days)) {                                                                   
            if (enabled && dayMapping[key]) {                                                                                                        
              accountWorkDays.push(dayMapping[key]);                                                                                                 
            }                                                                                                                                        
          }                                                                                                                                          
          if (accountWorkDays.length > 0) {                                                                                                          
            effectiveWorkDays = accountWorkDays;                                                                                                     
          }                                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        if (date) {                                                                                                                                  
          const holidayCheck = checkHoliday(date, agentTimezone);                                                                                    
          if (holidayCheck.isHoliday) {                                                                                                              
            return {                                                                                                                                 
              success: true,                                                                                                                         
              message: `Desculpe, ${date} é ${holidayCheck.holiday?.name}. Não temos atendimento nesse dia.`,                                        
              data: { availableSlots: [], totalSlots: 0, blockedReason: 'holiday' },                                                                 
              nextAction: 'continue',                                                                                                                
            };                                                                                                                                       
          }                                                                                                                                          
          datesToCheck = [date];                                                                                                                     
        } else {                                                                                                                                     
          datesToCheck = getNextBusinessDays(daysAhead!, effectiveWorkDays || undefined, agentTimezone);                                             
        }                                                                                                                                            
                                                                                                                                                     
        const allSlots: Array<{                                                                                                                      
          date: string;                                                                                                                              
          dateFormatted: string;                                                                                                                     
          slots: Array<{ time: string; start: string; end: string }>;                                                                                
          accountEmail?: string;                                                                                                                     
          isPrimary?: boolean;                                                                                                                       
        }> = [];                                                                                                                                     
                                                                                                                                                     
        if (hasMultipleAccounts) {                                                                                                                   
          const multiClient = createMultiCalendarClientFromAccounts(                                                                                 
            googleAccounts,                                                                                                                          
            process.env.GOOGLE_CLIENT_ID || '',                                                                                                      
            process.env.GOOGLE_CLIENT_SECRET || ''                                                                                                   
          );                                                                                                                                         
                                                                                                                                                     
          if (!multiClient) {                                                                                                                        
            return { success: false, message: 'Erro ao configurar agendas.', nextAction: 'continue' };                                               
          }                                                                                                                                          
                                                                                                                                                     
          for (const checkDate of datesToCheck) {                                                                                                    
            const result = await multiClient.getAvailabilityWithPriority({                                                                           
              date: checkDate,                                                                                                                       
              workHoursStart,                                                                                                                        
              workHoursEnd,                                                                                                                          
              slotDuration: duration,                                                                                                                
              breakBetweenSlots: 10,                                                                                                                 
              timezone: agentTimezone,                                                                                                               
            }, context.agentConfig.id);                                                                                                              
                                                                                                                                                     
            if (result.availableSlots.length > 0 && result.availableAccount) {                                                                       
              let filteredSlots = result.availableSlots;                                                                                             
              if (scheduleConfig) {                                                                                                                  
                filteredSlots = filterSlotsByPeriod(result.availableSlots, scheduleConfig, agentTimezone);                                           
              }                                                                                                                                      
              filteredSlots = filterSlotsForAgent(context.agentConfig.id, filteredSlots, agentTimezone);                                             
                                                                                                                                                     
              if (filteredSlots.length > 0) {                                                                                                        
                allSlots.push({                                                                                                                      
                  date: checkDate,                                                                                                                   
                  dateFormatted: formatDate(checkDate),                                                                                              
                  slots: filteredSlots.map((slot) => ({                                                                                              
                    time: formatTimeSlot(slot.start),                                                                                                
                    start: slot.start,                                                                                                               
                    end: slot.end,                                                                                                                   
                  })),                                                                                                                               
                  accountEmail: result.availableAccount.email,                                                                                       
                  isPrimary: result.availableAccountIndex === 0,                                                                                     
                });                                                                                                                                  
              }                                                                                                                                      
            }                                                                                                                                        
          }                                                                                                                                          
        } else {                                                                                                                                     
          const calendarClient = createGoogleCalendarClient({                                                                                        
            clientId: process.env.GOOGLE_CLIENT_ID || '',                                                                                            
            clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',                                                                                    
            refreshToken: googleCredentials.refresh_token,                                                                                           
            calendarId: googleCalendarId || 'primary',                                                                                               
          });                                                                                                                                        
                                                                                                                                                     
          for (const checkDate of datesToCheck) {                                                                                                    
            const availability = await calendarClient.getAvailability({                                                                              
              date: checkDate,                                                                                                                       
              workHoursStart,                                                                                                                        
              workHoursEnd,                                                                                                                          
              slotDuration: duration,                                                                                                                
              breakBetweenSlots: 10,                                                                                                                 
              timezone: agentTimezone,                                                                                                               
            });                                                                                                                                      
                                                                                                                                                     
            if (availability.availableSlots.length > 0) {                                                                                            
              let filteredSlots = availability.availableSlots;                                                                                       
              if (scheduleConfig) {                                                                                                                  
                filteredSlots = filterSlotsByPeriod(availability.availableSlots, scheduleConfig, agentTimezone);                                     
              }                                                                                                                                      
              filteredSlots = filterSlotsForAgent(context.agentConfig.id, filteredSlots, agentTimezone);                                             
                                                                                                                                                     
              if (filteredSlots.length > 0) {                                                                                                        
                allSlots.push({                                                                                                                      
                  date: checkDate,                                                                                                                   
                  dateFormatted: formatDate(checkDate),                                                                                              
                  slots: filteredSlots.map((slot) => ({                                                                                              
                    time: formatTimeSlot(slot.start),                                                                                                
                    start: slot.start,                                                                                                               
                    end: slot.end,                                                                                                                   
                  })),                                                                                                                               
                });                                                                                                                                  
              }                                                                                                                                      
            }                                                                                                                                        
          }                                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        if (allSlots.length === 0) {                                                                                                                 
          return {                                                                                                                                   
            success: true,                                                                                                                           
            message: 'Não há horários disponíveis nos próximos dias. Posso verificar outras datas?',                                                 
            data: { availableSlots: [], totalSlots: 0 },                                                                                             
            nextAction: 'continue',                                                                                                                  
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        const totalSlots = allSlots.reduce((acc, day) => acc + day.slots.length, 0);                                                                 
                                                                                                                                                     
        // Conversão de fuso horário do lead                                                                                                         
        let leadTimezone: string | null = null;                                                                                                      
        let sameFuso = true;                                                                                                                         
                                                                                                                                                     
        try {                                                                                                                                        
          const freshLead = await leadsRepository.getById(context.organizationId, context.leadId);                                                   
          if (freshLead?.timezone) {                                                                                                                 
            leadTimezone = freshLead.timezone;                                                                                                       
            sameFuso = isSameTimezone(leadTimezone, agentTimezone);                                                                                  
                                                                                                                                                     
            if (!sameFuso) {                                                                                                                         
              for (const daySlots of allSlots) {                                                                                                     
                for (const slot of daySlots.slots) {                                                                                                 
                  const converted = convertCreatorTimeToLeadTime(                                                                                    
                    slot.time, daySlots.date, agentTimezone, leadTimezone                                                                            
                  );                                                                                                                                 
                  slot.time = converted.time;                                                                                                        
                }                                                                                                                                    
              }                                                                                                                                      
            }                                                                                                                                        
          }                                                                                                                                          
        } catch (err) {                                                                                                                              
          console.warn('[ScheduleInquiry] Não foi possível verificar timezone do lead:', err);                                                       
        }                                                                                                                                            
                                                                                                                                                     
        // Extrair dados para resposta conversacional                                                                                                
        const diasDisponiveis = allSlots.map(day => {                                                                                                
          const data = new Date(day.date + 'T12:00:00');                                                                                             
          const diaSemana = data.toLocaleDateString('pt-BR', { weekday: 'long', timeZone: 'America/Sao_Paulo' });                                    
          return diaSemana.charAt(0).toUpperCase() + diaSemana.slice(1);                                                                             
        });                                                                                                                                          
                                                                                                                                                     
        const slotsHoje = allSlots[0]?.slots || [];                                                                                                  
        const slotsManha = slotsHoje.filter(s => parseInt(s.time.split(':')[0]) < 12).map(s => s.time);                                              
        const slotsTarde = slotsHoje.filter(s => parseInt(s.time.split(':')[0]) >= 12).map(s => s.time);                                             
                                                                                                                                                     
        const primeiroSlot = slotsManha[0] || slotsTarde[0] || 'sem horários';                                                                       
        const primeiroSlotTarde = slotsTarde[0] || 'sem horários à tarde';                                                                           
                                                                                                                                                     
        const horariosManhaStr = slotsManha.length > 0 ? slotsManha.join(', ') : 'NENHUM horário pela manhã';                                        
        const horariosTardeStr = slotsTarde.length > 0 ? slotsTarde.join(', ') : 'NENHUM horário à tarde';                                           
                                                                                                                                                     
        const conversationalInstruction = `                                                                                                          
  [INSTRUÇÃO INTERNA - NÃO MOSTRE ISSO AO CLIENTE]                                                                                                   
                                                                                                                                                     
  🚨 REGRA CRÍTICA - NUNCA INVENTE HORÁRIOS                                                                                                          
  Use APENAS os horários listados abaixo:                                                                                                            
  - MANHÃ: ${horariosManhaStr}                                                                                                                       
  - TARDE: ${horariosTardeStr}                                                                                                                       
                                                                                                                                                     
  ✅ FORMATO CONVERSACIONAL:                                                                                                                         
  1. Pergunte: "Tenho horários essa semana. Tem algum dia que fica melhor pra você?"                                                                 
  2. Ofereça opções: "${diasDisponiveis[0]} às ${primeiroSlot} pode ser?"                                                                            
  3. Confirme antes de agendar                                                                                                                       
                                                                                                                                                     
  Dias disponíveis: ${diasDisponiveis.join(', ')}                                                                                                    
  Total: ${totalSlots} slots                                                                                                                         
  `;                                                                                                                                                 
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: conversationalInstruction,                                                                                                        
          data: {                                                                                                                                    
            availableSlots: allSlots,                                                                                                                
            totalSlots,                                                                                                                              
            duration,                                                                                                                                
            calendarTimezone: agentTimezone,                                                                                                         
            diasDisponiveis,                                                                                                                         
            slotsManha,                                                                                                                              
            slotsTarde,                                                                                                                              
            leadTimezone,                                                                                                                            
            isSameTimezone: sameFuso,                                                                                                                
          },                                                                                                                                         
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';                                                           
        return { success: false, message: `Erro ao consultar horários: ${errorMessage}`, nextAction: 'continue' };                                   
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 14: tools/schedule-confirmation.tool.ts (622 linhas)                                                                                         
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult, ConversationState } from '../types';                                                                                          
  import {                                                                                                                                           
    createGoogleCalendarClient,                                                                                                                      
    createMultiCalendarClientFromAccounts,                                                                                                           
    GoogleAccount,                                                                                                                                   
    AgnesEventMetadata,                                                                                                                              
    AccountScheduleConfig,                                                                                                                           
    validateScheduleTime,                                                                                                                            
  } from '../../../services/calendar';                                                                                                               
  import { schedulesRepository, leadsRepository, agentsRepository } from '../../../services/supabase/repositories';                                  
  import { dynamicRepository } from '../../../services/supabase/repositories/dynamic.repository';                                                    
  import { scheduleConfirmations } from '../../../services/confirmation-scheduler';                                                                  
  import {                                                                                                                                           
    convertLeadTimeToCreatorTime,                                                                                                                    
    getTimezoneFriendlyName,                                                                                                                         
    isSameTimezone,                                                                                                                                  
  } from '../../../utils/timezone';                                                                                                                  
  import { checkHoliday } from '../../../utils/holidays';                                                                                            
  import { createUazapiClient } from '../../../services/uazapi';                                                                                     
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const scheduleConfirmationInputSchema = z.object({                                                                                          
    date: z.string().describe('Data do agendamento no formato YYYY-MM-DD'),                                                                          
    time: z.string().describe('Horário do agendamento no formato HH:MM'),                                                                            
    duration: z.number().optional().describe('Duração em minutos (default: 60)'),                                                                    
    title: z.string().optional().describe('Título do evento'),                                                                                       
    description: z.string().optional().describe('Descrição do evento'),                                                                              
    createMeetLink: z.boolean().optional().default(true).describe('Criar link do Google Meet'),                                                      
    sendNotification: z.boolean().optional().default(true).describe('Enviar notificação por email'),                                                 
  });                                                                                                                                                
                                                                                                                                                     
  export type ScheduleConfirmationInput = z.infer<typeof scheduleConfirmationInputSchema>;                                                           
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPER FUNCTIONS                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  function toISODateTime(date: string, time: string): string {                                                                                       
    const dateObj = new Date(`${date}T${time}:00`);                                                                                                  
    return dateObj.toISOString();                                                                                                                    
  }                                                                                                                                                  
                                                                                                                                                     
  function addMinutes(isoString: string, minutes: number): string {                                                                                  
    const date = new Date(isoString);                                                                                                                
    date.setMinutes(date.getMinutes() + minutes);                                                                                                    
    return date.toISOString();                                                                                                                       
  }                                                                                                                                                  
                                                                                                                                                     
  function formatDateTime(date: string, time: string, timezone: string = 'America/Sao_Paulo'): string {                                              
    const dateObj = new Date(`${date}T${time}:00`);                                                                                                  
    return dateObj.toLocaleDateString('pt-BR', {                                                                                                     
      weekday: 'long', day: '2-digit', month: 'long',                                                                                                
      hour: '2-digit', minute: '2-digit', timeZone: timezone,                                                                                        
    });                                                                                                                                              
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const scheduleConfirmationTool: Tool = {                                                                                                    
    name: TOOL_NAMES.SCHEDULE_CONFIRMATION,                                                                                                          
    description: `Confirma um agendamento e cria evento no Google Calendar com link do Google Meet.                                                  
  Use quando o cliente confirmar um horário específico ou escolher uma data/hora.`,                                                                  
                                                                                                                                                     
    inputSchema: scheduleConfirmationInputSchema,                                                                                                    
    requiresConfirmation: true,                                                                                                                      
    timeout: 20000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = scheduleConfirmationInputSchema.safeParse(input);                                                                               
                                                                                                                                                     
      if (!parsed.success) {                                                                                                                         
        return { success: false, message: `Parâmetros inválidos: ${parsed.error.message}`, nextAction: 'continue' };                                 
      }                                                                                                                                              
                                                                                                                                                     
      const { date, time, title, description, createMeetLink, sendNotification } = parsed.data;                                                      
      let { duration } = parsed.data;                                                                                                                
                                                                                                                                                     
      try {                                                                                                                                          
        const agentTimezone = context.agentConfig.timezone || 'America/Sao_Paulo';                                                                   
        const googleAccounts = context.integrations.google_accounts as GoogleAccount[] | null;                                                       
                                                                                                                                                     
        // Obter duração da reunião                                                                                                                  
        if (!duration) {                                                                                                                             
          if (googleAccounts && googleAccounts.length > 0) {                                                                                         
            duration = (googleAccounts[0] as any).meeting_duration;                                                                                  
          }                                                                                                                                          
          if (!duration) duration = context.agentConfig.meeting_duration as number | undefined;                                                      
          if (!duration) duration = 60;                                                                                                              
        }                                                                                                                                            
        if (![15, 30, 45, 60].includes(duration)) duration = 60;                                                                                     
                                                                                                                                                     
        // Verificar feriado                                                                                                                         
        const holidayCheck = checkHoliday(date, agentTimezone);                                                                                      
        if (holidayCheck.isHoliday) {                                                                                                                
          return {                                                                                                                                   
            success: false,                                                                                                                          
            message: `Desculpe, ${date} é ${holidayCheck.holiday?.name}. Podemos marcar para outro dia?`,                                            
            data: { blockedReason: 'holiday', holidayName: holidayCheck.holiday?.name },                                                             
            nextAction: 'continue',                                                                                                                  
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        // Validar horário contra configuração de períodos                                                                                           
        const businessHours = context.agentConfig.business_hours as any;                                                                             
        let scheduleConfig: AccountScheduleConfig | null = null;                                                                                     
                                                                                                                                                     
        if (googleAccounts && googleAccounts.length > 0) {                                                                                           
          const pa = googleAccounts[0] as any;                                                                                                       
          scheduleConfig = {                                                                                                                         
            morning_enabled: pa.morning_enabled !== undefined ? pa.morning_enabled === true : businessHours?.morning_enabled !== false,              
            morning_start: pa.morning_start || businessHours?.morning_start || '08:00',                                                              
            morning_end: pa.morning_end || businessHours?.morning_end || '12:00',                                                                    
            afternoon_enabled: pa.afternoon_enabled !== undefined ? pa.afternoon_enabled === true : businessHours?.afternoon_enabled !== false,      
            afternoon_start: pa.afternoon_start || businessHours?.afternoon_start || '14:00',                                                        
            afternoon_end: pa.afternoon_end || businessHours?.afternoon_end || '18:00',                                                              
            work_days: pa.work_days,                                                                                                                 
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        if (scheduleConfig) {                                                                                                                        
          const validation = validateScheduleTime(date, time, scheduleConfig);                                                                       
          if (!validation.allowed) {                                                                                                                 
            return {                                                                                                                                 
              success: false,                                                                                                                        
              message: validation.reason,                                                                                                            
              data: { blockedReason: 'outside_schedule' },                                                                                           
              nextAction: 'continue',                                                                                                                
            };                                                                                                                                       
          }                                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        const googleCredentials = context.integrations.google_credentials;                                                                           
        const googleCalendarId = context.integrations.google_calendar_id;                                                                            
        const hasMultipleAccounts = googleAccounts && googleAccounts.length > 0;                                                                     
        const hasSingleAccount = googleCredentials && googleCredentials.refresh_token;                                                               
                                                                                                                                                     
        if (!hasMultipleAccounts && !hasSingleAccount) {                                                                                             
          return { success: false, message: 'Google Calendar não configurado.', nextAction: 'continue' };                                            
        }                                                                                                                                            
                                                                                                                                                     
        // Conversão de timezone do lead para calendário                                                                                             
        let leadTimezone = (context.lead as any)?.timezone || null;                                                                                  
        try {                                                                                                                                        
          const freshLead = await leadsRepository.getById(context.organizationId, context.leadId);                                                   
          if (freshLead?.timezone) leadTimezone = freshLead.timezone;                                                                                
        } catch (err) {}                                                                                                                             
                                                                                                                                                     
        let finalDate = date;                                                                                                                        
        let finalTime = time;                                                                                                                        
                                                                                                                                                     
        if (leadTimezone && !isSameTimezone(leadTimezone, agentTimezone)) {                                                                          
          const converted = convertLeadTimeToCreatorTime(time, date, leadTimezone, agentTimezone);                                                   
          finalDate = converted.date;                                                                                                                
          finalTime = converted.time;                                                                                                                
        }                                                                                                                                            
                                                                                                                                                     
        const startDateTime = toISODateTime(finalDate, finalTime);                                                                                   
        const endDateTime = addMinutes(startDateTime, duration);                                                                                     
                                                                                                                                                     
        const eventTitle = title || `Reunião com ${context.lead.name || 'Cliente'}`;                                                                 
        const eventDescription = description || `Agendamento via WhatsApp.\nLead: ${context.lead.name}\nTelefone: ${context.lead.phone ||            
  context.remoteJid}`;                                                                                                                               
                                                                                                                                                     
        const agnesMetadata: AgnesEventMetadata = {                                                                                                  
          source: 'agnes',                                                                                                                           
          agent_id: context.agentId,                                                                                                                 
          remote_jid: context.remoteJid,                                                                                                             
          lead_id: context.leadId,                                                                                                                   
          organization_id: context.organizationId,                                                                                                   
          created_at: new Date().toISOString(),                                                                                                      
        };                                                                                                                                           
                                                                                                                                                     
        const eventInput = {                                                                                                                         
          summary: eventTitle,                                                                                                                       
          description: eventDescription,                                                                                                             
          startDateTime,                                                                                                                             
          endDateTime,                                                                                                                               
          timezone: agentTimezone,                                                                                                                   
          attendeeEmail: context.lead.email || undefined,                                                                                            
          attendeeName: context.lead.name || undefined,                                                                                              
          createMeetLink: createMeetLink!,                                                                                                           
          sendNotifications: sendNotification!,                                                                                                      
          agnesMetadata,                                                                                                                             
        };                                                                                                                                           
                                                                                                                                                     
        let eventId: string;                                                                                                                         
        let meetLink: string | undefined;                                                                                                            
        let htmlLink: string | undefined;                                                                                                            
        let primaryAccountEmail: string | undefined;                                                                                                 
                                                                                                                                                     
        if (hasMultipleAccounts) {                                                                                                                   
          const multiClient = createMultiCalendarClientFromAccounts(                                                                                 
            googleAccounts,                                                                                                                          
            process.env.GOOGLE_CLIENT_ID || '',                                                                                                      
            process.env.GOOGLE_CLIENT_SECRET || ''                                                                                                   
          );                                                                                                                                         
                                                                                                                                                     
          if (!multiClient) {                                                                                                                        
            return { success: false, message: 'Erro ao configurar agendas.', nextAction: 'continue' };                                               
          }                                                                                                                                          
                                                                                                                                                     
          const availabilityResult = await multiClient.getAvailabilityWithPriority({                                                                 
            date,                                                                                                                                    
            workHoursStart: context.agentConfig.work_hours_start || 9,                                                                               
            workHoursEnd: context.agentConfig.work_hours_end || 18,                                                                                  
            slotDuration: duration,                                                                                                                  
            breakBetweenSlots: 10,                                                                                                                   
            timezone: agentTimezone,                                                                                                                 
          }, context.agentConfig.id);                                                                                                                
                                                                                                                                                     
          if (availabilityResult.scenario === 'none' || availabilityResult.accountsToSchedule.length === 0) {                                        
            return {                                                                                                                                 
              success: false,                                                                                                                        
              message: 'Esse horário não está mais disponível. Posso verificar outros?',                                                             
              nextAction: 'continue',                                                                                                                
            };                                                                                                                                       
          }                                                                                                                                          
                                                                                                                                                     
          const result = await multiClient.createEventInAllCalendars(                                                                                
            eventInput,                                                                                                                              
            availabilityResult.accountsToSchedule,                                                                                                   
            availabilityResult.scenario                                                                                                              
          );                                                                                                                                         
                                                                                                                                                     
          eventId = result.primaryEvent.id;                                                                                                          
          primaryAccountEmail = result.primaryAccount.email;                                                                                         
                                                                                                                                                     
          if (result.primaryEvent.conferenceData?.entryPoints) {                                                                                     
            const videoEntry = result.primaryEvent.conferenceData.entryPoints.find(ep => ep.entryPointType === 'video');                             
            meetLink = videoEntry?.uri;                                                                                                              
          }                                                                                                                                          
          htmlLink = result.primaryEvent.htmlLink;                                                                                                   
        } else {                                                                                                                                     
          const calendarClient = createGoogleCalendarClient({                                                                                        
            clientId: process.env.GOOGLE_CLIENT_ID || '',                                                                                            
            clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',                                                                                    
            refreshToken: googleCredentials.refresh_token,                                                                                           
            calendarId: googleCalendarId || 'primary',                                                                                               
          });                                                                                                                                        
                                                                                                                                                     
          const event = await calendarClient.createEvent(eventInput);                                                                                
          eventId = event.id;                                                                                                                        
          htmlLink = event.htmlLink;                                                                                                                 
                                                                                                                                                     
          if (event.conferenceData?.entryPoints) {                                                                                                   
            const videoEntry = event.conferenceData.entryPoints.find(ep => ep.entryPointType === 'video');                                           
            meetLink = videoEntry?.uri;                                                                                                              
          }                                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        // Salvar agendamento                                                                                                                        
        await schedulesRepository.create(context.organizationId, {                                                                                   
          lead_id: context.leadId,                                                                                                                   
          event_id: eventId,                                                                                                                         
          scheduled_at: startDateTime,                                                                                                               
          duration_minutes: duration,                                                                                                                
          status: 'confirmed',                                                                                                                       
          meet_link: meetLink,                                                                                                                       
          notes: eventDescription,                                                                                                                   
          service_name: context.lead.pacote || null,                                                                                                 
        });                                                                                                                                          
                                                                                                                                                     
        // Sincronizar LeadboxCRM                                                                                                                    
        try {                                                                                                                                        
          const agent = await agentsRepository.findById(context.agentId);                                                                            
          if (agent?.table_leads && context.leadId) {                                                                                                
            const leadIdNum = parseInt(context.leadId, 10);                                                                                          
            if (!isNaN(leadIdNum)) {                                                                                                                 
              await dynamicRepository.updateLead(agent.table_leads, leadIdNum, {                                                                     
                next_appointment_at: startDateTime,                                                                                                  
                next_appointment_link: meetLink || null,                                                                                             
                last_scheduled_at: new Date().toISOString(),                                                                                         
                attended_by: 'agnes',                                                                                                                
                journey_stage: 'scheduled',                                                                                                          
              });                                                                                                                                    
            }                                                                                                                                        
          }                                                                                                                                          
        } catch (syncError) {}                                                                                                                       
                                                                                                                                                     
        // Agendar confirmações (24h e 2h antes)                                                                                                     
        try {                                                                                                                                        
          await scheduleConfirmations({                                                                                                              
            googleEventId: eventId,                                                                                                                  
            agentId: context.agentId,                                                                                                                
            remoteJid: context.remoteJid,                                                                                                            
            customerName: context.lead.name || 'Cliente',                                                                                            
            eventSummary: eventTitle,                                                                                                                
            eventStartAt: new Date(startDateTime),                                                                                                   
            eventTimezone: agentTimezone,                                                                                                            
          });                                                                                                                                        
        } catch (scheduleError) {}                                                                                                                   
                                                                                                                                                     
        // Notificar admin                                                                                                                           
        try {                                                                                                                                        
          const agent = await agentsRepository.findById(context.agentId);                                                                            
          if (agent?.owner_phone && agent.uazapi_base_url && agent.uazapi_token) {                                                                   
            const adminPhone = agent.owner_phone.includes('@') ? agent.owner_phone : `${agent.owner_phone}@s.whatsapp.net`;                          
            const uazapiClient = createUazapiClient({ baseUrl: agent.uazapi_base_url, instanceToken: agent.uazapi_token });                          
                                                                                                                                                     
            const notificationMessage = `📅 *Novo Agendamento!*\n\n👤 *Lead:* ${context.lead.name || 'Não informado'}\n🗓️ *Data:* ${date}\n⏰        
  *Horário:* ${time}${meetLink ? `\n🔗 *Link:* ${meetLink}` : ''}`;                                                                                  
            await uazapiClient.sendText(adminPhone, notificationMessage);                                                                            
          }                                                                                                                                          
        } catch (notifyError) {}                                                                                                                     
                                                                                                                                                     
        const displayTimezone = leadTimezone || agentTimezone;                                                                                       
        const formattedDateTime = formatDateTime(date, time, displayTimezone);                                                                       
                                                                                                                                                     
        let responseMessage = `Agendamento confirmado para ${formattedDateTime}.`;                                                                   
        if (meetLink) responseMessage += `\n\nLink da reunião: ${meetLink}`;                                                                         
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: responseMessage,                                                                                                                  
          data: {                                                                                                                                    
            eventId, title: eventTitle, date: finalDate, time: finalTime,                                                                            
            leadDate: date, leadTime: time, leadTimezone, calendarTimezone: agentTimezone,                                                           
            duration, meetLink, htmlLink, status: 'confirmed', primaryAccountEmail,                                                                  
          },                                                                                                                                         
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';                                                           
        return { success: false, message: `Erro ao criar agendamento: ${errorMessage}`, nextAction: 'continue' };                                    
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 15: tools/payment-link.tool.ts (527 linhas)                                                                                                  
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import { AsaasClient, createAsaasClient } from '../../../services/asaas';                                                                          
  import { paymentsRepository, leadsRepository } from '../../../services/supabase/repositories';                                                     
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const paymentLinkInputSchema = z.object({                                                                                                   
    value: z.number().positive().describe('Valor do pagamento em reais (ex: 997.00)'),                                                               
    description: z.string().describe('Descrição do produto ou serviço'),                                                                             
    billingType: z.enum(['BOLETO', 'PIX', 'CREDIT_CARD', 'UNDEFINED']).optional().default('UNDEFINED'),                                              
    chargeType: z.enum(['DETACHED', 'RECURRENT']).optional().default('DETACHED'),                                                                    
    subscriptionCycle: z.enum(['WEEKLY', 'BIWEEKLY', 'MONTHLY', 'BIMONTHLY', 'QUARTERLY', 'SEMIANNUALLY', 'YEARLY']).optional(),                     
    dueDate: z.string().optional().describe('Data de vencimento YYYY-MM-DD'),                                                                        
    maxInstallments: z.number().min(1).max(12).optional().default(1),                                                                                
    expirationDays: z.number().optional().default(7),                                                                                                
  });                                                                                                                                                
                                                                                                                                                     
  export type PaymentLinkInput = z.infer<typeof paymentLinkInputSchema>;                                                                             
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPER FUNCTIONS                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  function formatCurrency(value: number): string {                                                                                                   
    return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });                                                                    
  }                                                                                                                                                  
                                                                                                                                                     
  function addDays(date: Date, days: number): string {                                                                                               
    const result = new Date(date);                                                                                                                   
    result.setDate(result.getDate() + days);                                                                                                         
    return result.toISOString().split('T')[0];                                                                                                       
  }                                                                                                                                                  
                                                                                                                                                     
  function formatDate(dateString: string): string {                                                                                                  
    const date = new Date(dateString + 'T12:00:00');                                                                                                 
    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });                                                  
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // PAYMENT LINK TOOL                                                                                                                               
  // ============================================================================                                                                    
                                                                                                                                                     
  export const paymentLinkTool: Tool = {                                                                                                             
    name: TOOL_NAMES.PAYMENT_LINK_REQUEST,                                                                                                           
    description: `Gera um link de pagamento para o cliente via Asaas.                                                                                
  Use quando o cliente quiser pagar, solicitar boleto/pix ou confirmar compra.                                                                       
  Suporta Pix, Boleto e Cartão de Crédito.`,                                                                                                         
                                                                                                                                                     
    inputSchema: paymentLinkInputSchema,                                                                                                             
    requiresConfirmation: true,                                                                                                                      
    timeout: 20000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = paymentLinkInputSchema.safeParse(input);                                                                                        
      if (!parsed.success) {                                                                                                                         
        return { success: false, message: `Parâmetros inválidos: ${parsed.error.message}`, nextAction: 'continue' };                                 
      }                                                                                                                                              
                                                                                                                                                     
      const { value, description, billingType, chargeType, subscriptionCycle, dueDate, maxInstallments, expirationDays } = parsed.data;              
                                                                                                                                                     
      if (chargeType === 'RECURRENT' && !subscriptionCycle) {                                                                                        
        return { success: false, message: 'Para assinatura recorrente, informe subscriptionCycle.', nextAction: 'continue' };                        
      }                                                                                                                                              
                                                                                                                                                     
      try {                                                                                                                                          
        const asaasApiKey = context.integrations.asaas_api_key;                                                                                      
        if (!asaasApiKey) {                                                                                                                          
          return { success: false, message: 'Integração com Asaas não configurada.', nextAction: 'continue' };                                       
        }                                                                                                                                            
                                                                                                                                                     
        const asaasClient = createAsaasClient({ apiKey: asaasApiKey });                                                                              
                                                                                                                                                     
        let customerId = context.lead.asaas_customer_id;                                                                                             
        if (!customerId) {                                                                                                                           
          const customer = await asaasClient.getOrCreateCustomer({                                                                                   
            name: context.lead.name || `Lead ${context.remoteJid}`,                                                                                  
            email: context.lead.email || undefined,                                                                                                  
            phone: context.lead.phone || context.remoteJid.replace('@s.whatsapp.net', ''),                                                           
            cpfCnpj: context.lead.cpf_cnpj || undefined,                                                                                             
          });                                                                                                                                        
          customerId = customer.id;                                                                                                                  
          await leadsRepository.update(context.organizationId, context.leadId, { asaas_customer_id: customerId });                                   
        }                                                                                                                                            
                                                                                                                                                     
        const dueDateValue = dueDate || addDays(new Date(), expirationDays!);                                                                        
        const isSubscription = chargeType === 'RECURRENT';                                                                                           
                                                                                                                                                     
        const paymentLink = await asaasClient.createPaymentLink({                                                                                    
          name: description,                                                                                                                         
          description: `${isSubscription ? 'Assinatura' : 'Pagamento'} via WhatsApp - ${context.lead.name || 'Cliente'}`,                            
          value,                                                                                                                                     
          billingType: billingType === 'UNDEFINED' ? undefined : billingType,                                                                        
          chargeType,                                                                                                                                
          subscriptionCycle: isSubscription ? subscriptionCycle : undefined,                                                                         
          dueDateLimitDays: expirationDays,                                                                                                          
          maxInstallmentCount: !isSubscription && maxInstallments! > 1 ? maxInstallments : undefined,                                                
          notificationEnabled: true,                                                                                                                 
        });                                                                                                                                          
                                                                                                                                                     
        await paymentsRepository.create(context.organizationId, {                                                                                    
          lead_id: context.leadId,                                                                                                                   
          asaas_payment_id: paymentLink.id,                                                                                                          
          amount: value,                                                                                                                             
          status: 'pending',                                                                                                                         
          payment_method: billingType === 'UNDEFINED' ? null : billingType!.toLowerCase(),                                                           
          due_date: dueDateValue,                                                                                                                    
          payment_link: paymentLink.url,                                                                                                             
        });                                                                                                                                          
                                                                                                                                                     
        const formattedValue = formatCurrency(value);                                                                                                
        const cycleLabels: Record<string, string> = {                                                                                                
          WEEKLY: 'Semanal', BIWEEKLY: 'Quinzenal', MONTHLY: 'Mensal',                                                                               
          BIMONTHLY: 'Bimestral', QUARTERLY: 'Trimestral', SEMIANNUALLY: 'Semestral', YEARLY: 'Anual',                                               
        };                                                                                                                                           
                                                                                                                                                     
        let responseMessage = isSubscription ? `Link de assinatura gerado!\n\n` : `Link de pagamento gerado!\n\n`;                                   
        responseMessage += `💰 Valor: ${formattedValue}${isSubscription && subscriptionCycle ? ` (${cycleLabels[subscriptionCycle]})` : ''}\n`;      
        responseMessage += `📝 Descrição: ${description}\n`;                                                                                         
        responseMessage += isSubscription ? `🔄 Tipo: Assinatura Recorrente\n` : `📅 Vencimento: ${formatDate(dueDateValue)}\n`;                     
        responseMessage += `\n🔗 Link: ${paymentLink.url}`;                                                                                          
        if (!isSubscription && maxInstallments! > 1) responseMessage += `\n\n💳 Parcelamento em até ${maxInstallments}x`;                            
        responseMessage += `\n\n⚠️ INSTRUÇÃO: Envie o link SEM formatação markdown: ${paymentLink.url}`;                                             
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: responseMessage,                                                                                                                  
          data: { paymentLinkId: paymentLink.id, url: paymentLink.url, value, formattedValue, isSubscription },                                      
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro ao gerar link: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };        
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // CHECK PAYMENT STATUS TOOL                                                                                                                       
  // ============================================================================                                                                    
                                                                                                                                                     
  export const checkPaymentStatusInputSchema = z.object({                                                                                            
    paymentId: z.string().optional().describe('ID do pagamento. Se não informado, busca o último do lead.'),                                         
  });                                                                                                                                                
                                                                                                                                                     
  export type CheckPaymentStatusInput = z.infer<typeof checkPaymentStatusInputSchema>;                                                               
                                                                                                                                                     
  export const checkPaymentStatusTool: Tool = {                                                                                                      
    name: TOOL_NAMES.CHECK_PAYMENT_STATUS,                                                                                                           
    description: `Verifica o status de um pagamento no Asaas.`,                                                                                      
    inputSchema: checkPaymentStatusInputSchema,                                                                                                      
    requiresConfirmation: false,                                                                                                                     
    timeout: 15000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = checkPaymentStatusInputSchema.safeParse(input);                                                                                 
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { paymentId } = parsed.data;                                                                                                             
                                                                                                                                                     
      try {                                                                                                                                          
        const asaasApiKey = context.integrations.asaas_api_key;                                                                                      
        if (!asaasApiKey) return { success: false, message: 'Asaas não configurado.', nextAction: 'continue' };                                      
                                                                                                                                                     
        let payment;                                                                                                                                 
        if (paymentId) {                                                                                                                             
          payment = await paymentsRepository.getByAsaasId(context.organizationId, paymentId);                                                        
        } else {                                                                                                                                     
          const payments = await paymentsRepository.listByLead(context.leadId);                                                                      
          payment = payments[0];                                                                                                                     
        }                                                                                                                                            
                                                                                                                                                     
        if (!payment) return { success: true, message: 'Nenhum pagamento pendente.', data: { found: false }, nextAction: 'continue' };               
                                                                                                                                                     
        const asaasClient = createAsaasClient({ apiKey: asaasApiKey });                                                                              
        const asaasPayment = await asaasClient.getPayment(payment.asaas_payment_id);                                                                 
                                                                                                                                                     
        if (!asaasPayment) return { success: true, message: 'Pagamento não encontrado.', data: { found: false }, nextAction: 'continue' };           
                                                                                                                                                     
        if (asaasPayment.status !== payment.status) {                                                                                                
          await paymentsRepository.update(context.organizationId, payment.id, { status: asaasPayment.status.toLowerCase() });                        
        }                                                                                                                                            
                                                                                                                                                     
        const statusMessages: Record<string, string> = {                                                                                             
          PENDING: 'Aguardando pagamento', RECEIVED: 'Pagamento confirmado! ✅',                                                                     
          CONFIRMED: 'Pagamento confirmado! ✅', OVERDUE: 'Pagamento vencido',                                                                       
        };                                                                                                                                           
                                                                                                                                                     
        const isPaid = ['RECEIVED', 'CONFIRMED', 'RECEIVED_IN_CASH'].includes(asaasPayment.status);                                                  
        let responseMessage = `Status: ${statusMessages[asaasPayment.status] || asaasPayment.status}\nValor: ${formatCurrency(asaasPayment.value)}`; 
        if (!isPaid && payment.payment_link) responseMessage += `\n\nLink: ${payment.payment_link}`;                                                 
                                                                                                                                                     
        return { success: true, message: responseMessage, data: { found: true, status: asaasPayment.status, isPaid }, nextAction: isPaid ? 'respond' 
  : 'continue' };                                                                                                                                    
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // TEST ASAAS CONNECTION TOOL                                                                                                                      
  // ============================================================================                                                                    
                                                                                                                                                     
  export const testAsaasConnectionInputSchema = z.object({});                                                                                        
  export type TestAsaasConnectionInput = z.infer<typeof testAsaasConnectionInputSchema>;                                                             
                                                                                                                                                     
  export const testAsaasConnectionTool: Tool = {                                                                                                     
    name: TOOL_NAMES.TEST_ASAAS_CONNECTION,                                                                                                          
    description: `Testa a conexão com a API do Asaas.`,                                                                                              
    inputSchema: testAsaasConnectionInputSchema,                                                                                                     
    requiresConfirmation: false,                                                                                                                     
    timeout: 15000,                                                                                                                                  
                                                                                                                                                     
    async execute(_input: unknown, context: ToolContext): Promise<ToolResult> {                                                                      
      try {                                                                                                                                          
        const asaasApiKey = context.integrations.asaas_api_key;                                                                                      
        if (!asaasApiKey) return { success: false, message: 'Asaas não configurado.', data: { configured: false }, nextAction: 'continue' };         
                                                                                                                                                     
        const asaasClient = createAsaasClient({ apiKey: asaasApiKey });                                                                              
        const result = await asaasClient.testConnection();                                                                                           
                                                                                                                                                     
        if (result.success) {                                                                                                                        
          return { success: true, message: `Conexão OK! Clientes: ${result.details?.totalCustomers}`, data: { configured: true, connected: true },   
  nextAction: 'continue' };                                                                                                                          
        }                                                                                                                                            
        return { success: false, message: `Erro: ${result.message}`, data: { configured: true, connected: false }, nextAction: 'continue' };         
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 16: tools/human-handoff.tool.ts (275 linhas)                                                                                                 
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult, ConversationState } from '../types';                                                                                          
  import { leadsRepository, messagesRepository } from '../../../services/supabase/repositories';                                                     
  import { LeadStatus } from '../../../services/supabase/types';                                                                                     
                                                                                                                                                     
  // ============================================================================                                                                    
  // DEPARTMENT IDS (Leadbox Format)                                                                                                                 
  // ============================================================================                                                                    
                                                                                                                                                     
  export const DEPARTMENT_ID_MAP: Record<string, string> = {                                                                                         
    '459': 'suporte',                                                                                                                                
    '460': 'financeiro',                                                                                                                             
    '461': 'implantação',                                                                                                                            
    '462': 'vendas',                                                                                                                                 
    '463': 'comercial',                                                                                                                              
  };                                                                                                                                                 
                                                                                                                                                     
  export const DEPARTMENT_NAME_TO_ID: Record<string, string> = {                                                                                     
    suporte: '459',                                                                                                                                  
    financeiro: '460',                                                                                                                               
    implantacao: '461',                                                                                                                              
    implantação: '461',                                                                                                                              
    vendas: '462',                                                                                                                                   
    comercial: '463',                                                                                                                                
  };                                                                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const humanHandoffInputSchema = z.object({                                                                                                  
    reason: z.string().describe('Motivo da transferência para atendimento humano'),                                                                  
    priority: z.enum(['low', 'medium', 'high', 'urgent']).optional().default('medium'),                                                              
    department: z.string().optional().describe('Departamento específico'),                                                                           
    department_id: z.string().optional().describe('ID do departamento (459-463)'),                                                                   
    summary: z.string().optional().describe('Resumo da conversa'),                                                                                   
    customerSentiment: z.enum(['positive', 'neutral', 'negative', 'frustrated']).optional().default('neutral'),                                      
  });                                                                                                                                                
                                                                                                                                                     
  export type HumanHandoffInput = z.infer<typeof humanHandoffInputSchema>;                                                                           
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPER FUNCTIONS                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  function resolveDepartment(departmentId?: string, departmentName?: string): { name: string | undefined; id: string | undefined } {                 
    if (departmentId && DEPARTMENT_ID_MAP[departmentId]) {                                                                                           
      return { name: DEPARTMENT_ID_MAP[departmentId], id: departmentId };                                                                            
    }                                                                                                                                                
    if (departmentName) {                                                                                                                            
      const normalizedName = departmentName.toLowerCase().trim();                                                                                    
      const id = DEPARTMENT_NAME_TO_ID[normalizedName];                                                                                              
      return { name: departmentName, id };                                                                                                           
    }                                                                                                                                                
    return { name: undefined, id: undefined };                                                                                                       
  }                                                                                                                                                  
                                                                                                                                                     
  function getTransferMessage(priority: string, department?: string): string {                                                                       
    const deptText = department ? ` da área de ${department}` : '';                                                                                  
    switch (priority) {                                                                                                                              
      case 'urgent': return `Vou transferir você imediatamente para um especialista${deptText}. Aguarde!`;                                           
      case 'high': return `Entendo a urgência! Estou transferindo${deptText}. Aguarde um momento.`;                                                  
      case 'low': return `Vou encaminhar sua solicitação${deptText}. Em breve entrarão em contato.`;                                                 
      default: return `Vou transferir você para um atendente${deptText}. Aguarde um momento, por favor.`;                                            
    }                                                                                                                                                
  }                                                                                                                                                  
                                                                                                                                                     
  function formatLeadInfoForAgent(context: ToolContext, input: HumanHandoffInput): string {                                                          
    const lines = [                                                                                                                                  
      '=== INFORMAÇÕES DO LEAD ===',                                                                                                                 
      `Nome: ${context.lead.name || 'Não informado'}`,                                                                                               
      `Telefone: ${context.lead.phone || context.remoteJid}`,                                                                                        
      `Email: ${context.lead.email || 'Não informado'}`,                                                                                             
      '',                                                                                                                                            
      '=== CONTEXTO ===',                                                                                                                            
      `Motivo: ${input.reason}`,                                                                                                                     
      `Prioridade: ${input.priority?.toUpperCase()}`,                                                                                                
      `Sentimento: ${input.customerSentiment}`,                                                                                                      
    ];                                                                                                                                               
    if (input.department) lines.push(`Departamento: ${input.department}`);                                                                           
    if (input.summary) lines.push('', '=== RESUMO ===', input.summary);                                                                              
    return lines.join('\n');                                                                                                                         
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const humanHandoffTool: Tool = {                                                                                                            
    name: TOOL_NAMES.HUMAN_HANDOFF,                                                                                                                  
    description: `Transfere o atendimento para um humano.                                                                                            
  Use quando:                                                                                                                                        
  - O cliente pedir para falar com uma pessoa                                                                                                        
  - A situação for muito complexa                                                                                                                    
  - O cliente estiver frustrado                                                                                                                      
  - For necessária decisão que só humanos podem tomar`,                                                                                              
                                                                                                                                                     
    inputSchema: humanHandoffInputSchema,                                                                                                            
    requiresConfirmation: false,                                                                                                                     
    timeout: 10000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = humanHandoffInputSchema.safeParse(input);                                                                                       
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const handoffData = parsed.data;                                                                                                               
                                                                                                                                                     
      try {                                                                                                                                          
        const resolvedDept = resolveDepartment(handoffData.department_id, handoffData.department);                                                   
        const departmentName = resolvedDept.name;                                                                                                    
        const departmentId = resolvedDept.id;                                                                                                        
                                                                                                                                                     
        const handoffDataWithDept = { ...handoffData, department: departmentName };                                                                  
        const agentInfo = formatLeadInfoForAgent(context, handoffDataWithDept);                                                                      
                                                                                                                                                     
        await leadsRepository.update(context.organizationId, context.leadId, {                                                                       
          status: LeadStatus.OPEN,                                                                                                                   
          current_state: ConversationState.HUMAN_HANDOFF,                                                                                            
          handoff_reason: handoffData.reason,                                                                                                        
          handoff_priority: handoffData.priority,                                                                                                    
          handoff_department: departmentName,                                                                                                        
          handoff_department_id: departmentId,                                                                                                       
          handoff_at: new Date().toISOString(),                                                                                                      
        });                                                                                                                                          
                                                                                                                                                     
        await messagesRepository.create(context.leadId, {                                                                                            
          role: 'system',                                                                                                                            
          content: `[HANDOFF INICIADO]\n\n${agentInfo}\n\nDepartamento ID: ${departmentId || 'N/A'}`,                                                
          message_type: 'text',                                                                                                                      
        });                                                                                                                                          
                                                                                                                                                     
        const transferMessage = getTransferMessage(handoffData.priority!, departmentName);                                                           
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: transferMessage,                                                                                                                  
          data: {                                                                                                                                    
            handoff: true,                                                                                                                           
            leadId: context.leadId,                                                                                                                  
            reason: handoffData.reason,                                                                                                              
            priority: handoffData.priority,                                                                                                          
            department: departmentName,                                                                                                              
            department_id: departmentId,                                                                                                             
            agentInfo,                                                                                                                               
            timestamp: new Date().toISOString(),                                                                                                     
          },                                                                                                                                         
          nextAction: 'handoff',                                                                                                                     
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: 'Não foi possível transferir. Nossa equipe entrará em contato.', nextAction: 'continue' };                 
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 17: tools/no-interest.tool.ts (358 linhas)                                                                                                   
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult, ConversationState } from '../types';                                                                                          
  import { leadsRepository, messagesRepository } from '../../../services/supabase/repositories';                                                     
  import { LeadStatus } from '../../../services/supabase/types';                                                                                     
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMAS                                                                                                                                   
  // ============================================================================                                                                    
                                                                                                                                                     
  export const noInterestInputSchema = z.object({                                                                                                    
    reason: z.string().describe('Motivo do desinteresse'),                                                                                           
    category: z.enum(['price', 'timing', 'competitor', 'no_need', 'no_fit', 'other']).optional().default('other'),                                   
    recontact: z.boolean().optional().default(true),                                                                                                 
    recontactDays: z.number().optional().default(30),                                                                                                
    feedback: z.string().optional(),                                                                                                                 
  });                                                                                                                                                
                                                                                                                                                     
  export type NoInterestInput = z.infer<typeof noInterestInputSchema>;                                                                               
                                                                                                                                                     
  export const finalizeAttendanceInputSchema = z.object({                                                                                            
    outcome: z.enum(['success', 'scheduled', 'no_interest', 'follow_up', 'qualified']),                                                              
    notes: z.string().optional(),                                                                                                                    
    nextSteps: z.string().optional(),                                                                                                                
  });                                                                                                                                                
                                                                                                                                                     
  export type FinalizeAttendanceInput = z.infer<typeof finalizeAttendanceInputSchema>;                                                               
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPER FUNCTIONS                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  function getFarewellMessage(category: string, recontact: boolean): string {                                                                        
    const baseMessages: Record<string, string> = {                                                                                                   
      price: 'Entendo! Se mudar de ideia sobre o investimento, estarei aqui.',                                                                       
      timing: 'Sem problemas! Quando o momento for adequado, é só me chamar.',                                                                       
      competitor: 'Compreendo. Se precisar avaliar outras opções, conte comigo.',                                                                    
      no_need: 'Tudo bem! Se a situação mudar, fico à disposição.',                                                                                  
      no_fit: 'Entendo que não é o melhor fit agora. Obrigado pelo seu tempo!',                                                                      
      other: 'Agradeço pelo seu tempo! Se precisar de algo, estarei aqui.',                                                                          
    };                                                                                                                                               
    let message = baseMessages[category] || baseMessages.other;                                                                                      
    if (recontact) message += ' Posso entrar em contato novamente em algumas semanas?';                                                              
    return message;                                                                                                                                  
  }                                                                                                                                                  
                                                                                                                                                     
  function calculateRecontactDate(days: number): string {                                                                                            
    const date = new Date();                                                                                                                         
    date.setDate(date.getDate() + days);                                                                                                             
    return date.toISOString().split('T')[0];                                                                                                         
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // NO INTEREST TOOL                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  export const noInterestTool: Tool = {                                                                                                              
    name: TOOL_NAMES.NO_INTEREST_DETECTED,                                                                                                           
    description: `Registra que o cliente não tem interesse no momento.                                                                               
  Use quando o cliente disser que não quer, já usa concorrente, ou não é o momento.`,                                                                
                                                                                                                                                     
    inputSchema: noInterestInputSchema,                                                                                                              
    requiresConfirmation: false,                                                                                                                     
    timeout: 10000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = noInterestInputSchema.safeParse(input);                                                                                         
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { reason, category, recontact, recontactDays, feedback } = parsed.data;                                                                  
                                                                                                                                                     
      try {                                                                                                                                          
        const recontactDate = recontact ? calculateRecontactDate(recontactDays!) : null;                                                             
        const timestamp = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });                                                     
                                                                                                                                                     
        const noteContent = [                                                                                                                        
          `[${timestamp} - Sem Interesse]`,                                                                                                          
          `Motivo: ${reason}`,                                                                                                                       
          `Categoria: ${category}`,                                                                                                                  
          feedback ? `Feedback: ${feedback}` : null,                                                                                                 
          recontact ? `Recontato: ${recontactDate}` : 'Sem recontato',                                                                               
        ].filter(Boolean).join('\n');                                                                                                                
                                                                                                                                                     
        const existingNotes = context.lead.notes || '';                                                                                              
        const updatedNotes = existingNotes ? `${existingNotes}\n\n${noteContent}` : noteContent;                                                     
                                                                                                                                                     
        await leadsRepository.update(context.organizationId, context.leadId, {                                                                       
          status: LeadStatus.LOST,                                                                                                                   
          pipeline_step: 'closed_lost',                                                                                                              
          atendimento_finalizado: !recontact,                                                                                                        
          lost_reason: reason,                                                                                                                       
          lost_category: category,                                                                                                                   
          recontact_date: recontactDate,                                                                                                             
          notes: updatedNotes,                                                                                                                       
        });                                                                                                                                          
                                                                                                                                                     
        await messagesRepository.create(context.leadId, {                                                                                            
          role: 'system',                                                                                                                            
          content: `[LEAD SEM INTERESSE]\n${noteContent}`,                                                                                           
          message_type: 'text',                                                                                                                      
        });                                                                                                                                          
                                                                                                                                                     
        const farewellMessage = getFarewellMessage(category!, recontact!);                                                                           
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: farewellMessage,                                                                                                                  
          data: { noInterest: true, reason, category, recontact, recontactDate, status: LeadStatus.LOST },                                           
          nextAction: 'respond',                                                                                                                     
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // FINALIZE ATTENDANCE TOOL                                                                                                                        
  // ============================================================================                                                                    
                                                                                                                                                     
  export const finalizeAttendanceTool: Tool = {                                                                                                      
    name: TOOL_NAMES.FINALIZE_ATTENDANCE,                                                                                                            
    description: `Finaliza o atendimento atual com o resultado apropriado.`,                                                                         
                                                                                                                                                     
    inputSchema: finalizeAttendanceInputSchema,                                                                                                      
    requiresConfirmation: false,                                                                                                                     
    timeout: 10000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = finalizeAttendanceInputSchema.safeParse(input);                                                                                 
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { outcome, notes, nextSteps } = parsed.data;                                                                                             
                                                                                                                                                     
      try {                                                                                                                                          
        const outcomeConfig: Record<string, { status: LeadStatus; pipeline: string; state: ConversationState; finalized: boolean }> = {              
          success: { status: LeadStatus.WON, pipeline: 'closed_won', state: ConversationState.CLOSING_WON, finalized: true },                        
          scheduled: { status: LeadStatus.OPEN, pipeline: 'proposal', state: ConversationState.SCHEDULING, finalized: false },                       
          no_interest: { status: LeadStatus.LOST, pipeline: 'closed_lost', state: ConversationState.CLOSING_LOST, finalized: true },                 
          follow_up: { status: LeadStatus.OPEN, pipeline: 'qualified', state: ConversationState.FOLLOW_UP, finalized: false },                       
          qualified: { status: LeadStatus.OPEN, pipeline: 'qualified', state: ConversationState.QUALIFICATION, finalized: false },                   
        };                                                                                                                                           
                                                                                                                                                     
        const config = outcomeConfig[outcome];                                                                                                       
        const timestamp = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });                                                     
                                                                                                                                                     
        const noteLines = [`[${timestamp} - Atendimento Finalizado]`, `Resultado: ${outcome}`];                                                      
        if (notes) noteLines.push(`Notas: ${notes}`);                                                                                                
        if (nextSteps) noteLines.push(`Próximos passos: ${nextSteps}`);                                                                              
                                                                                                                                                     
        const existingNotes = context.lead.notes || '';                                                                                              
        const updatedNotes = existingNotes ? `${existingNotes}\n\n${noteLines.join('\n')}` : noteLines.join('\n');                                   
                                                                                                                                                     
        await leadsRepository.update(context.organizationId, context.leadId, {                                                                       
          status: config.status,                                                                                                                     
          pipeline_step: config.pipeline,                                                                                                            
          current_state: config.state,                                                                                                               
          atendimento_finalizado: config.finalized,                                                                                                  
          notes: updatedNotes,                                                                                                                       
        });                                                                                                                                          
                                                                                                                                                     
        const closingMessages: Record<string, string> = {                                                                                            
          success: 'Ótimo! Fico feliz em ter ajudado. Qualquer dúvida, estou à disposição!',                                                         
          scheduled: 'Perfeito! Nos vemos na reunião agendada. Até lá!',                                                                             
          no_interest: 'Agradeço o contato. Se mudar de ideia, estarei aqui!',                                                                       
          follow_up: 'Vou anotar para dar continuidade. Até breve!',                                                                                 
          qualified: 'Excelente! Vou encaminhar para a próxima etapa.',                                                                              
        };                                                                                                                                           
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: closingMessages[outcome],                                                                                                         
          data: { outcome, status: config.status, pipeline: config.pipeline, finalized: config.finalized },                                          
          nextAction: 'respond',                                                                                                                     
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 18: tools/update-lead.tool.ts (413 linhas)                                                                                                   
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import { leadsRepository } from '../../../services/supabase/repositories';                                                                         
  import { detectTimezoneFromCity, getTimezoneFriendlyName } from '../../../utils/timezone';                                                         
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const updateLeadInputSchema = z.object({                                                                                                    
    name: z.string().optional().describe('Nome completo do lead'),                                                                                   
    email: z.string().email().optional().describe('Email do lead'),                                                                                  
    phone: z.string().optional().describe('Telefone do lead'),                                                                                       
    company: z.string().optional().describe('Nome da empresa'),                                                                                      
    role: z.string().optional().describe('Cargo/função'),                                                                                            
    employees: z.number().optional().describe('Número de funcionários'),                                                                             
    segment: z.string().optional().describe('Segmento/indústria'),                                                                                   
    cidade: z.string().optional().describe('Cidade (IMPORTANTE para fuso horário)'),                                                                 
    estado: z.string().optional().describe('Estado/UF'),                                                                                             
    notes: z.string().optional().describe('Observações adicionais'),                                                                                 
  });                                                                                                                                                
                                                                                                                                                     
  export type UpdateLeadInput = z.infer<typeof updateLeadInputSchema>;                                                                               
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const updateLeadTool: Tool = {                                                                                                              
    name: TOOL_NAMES.UPDATE_LEAD,                                                                                                                    
    description: `Atualiza informações do lead no banco de dados.                                                                                    
  Use quando o cliente mencionar nome, email, empresa, cargo, cidade, etc.                                                                           
  ⚠️ SEMPRE salve a CIDADE quando o lead informar de onde está - essencial para fuso horário!`,                                                      
                                                                                                                                                     
    inputSchema: updateLeadInputSchema,                                                                                                              
    requiresConfirmation: false,                                                                                                                     
    timeout: 10000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = updateLeadInputSchema.safeParse(input);                                                                                         
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const updates = parsed.data;                                                                                                                   
      const fieldsToUpdate: Record<string, unknown> = {};                                                                                            
      const updatedFields: string[] = [];                                                                                                            
                                                                                                                                                     
      if (updates.name && updates.name !== context.lead.name) {                                                                                      
        fieldsToUpdate.name = updates.name;                                                                                                          
        updatedFields.push(`nome: ${updates.name}`);                                                                                                 
      }                                                                                                                                              
      if (updates.email && updates.email !== context.lead.email) {                                                                                   
        fieldsToUpdate.email = updates.email;                                                                                                        
        updatedFields.push(`email: ${updates.email}`);                                                                                               
      }                                                                                                                                              
      if (updates.phone && updates.phone !== context.lead.phone) {                                                                                   
        fieldsToUpdate.phone = updates.phone;                                                                                                        
        updatedFields.push(`telefone: ${updates.phone}`);                                                                                            
      }                                                                                                                                              
      if (updates.company && updates.company !== context.lead.company) {                                                                             
        fieldsToUpdate.company = updates.company;                                                                                                    
        updatedFields.push(`empresa: ${updates.company}`);                                                                                           
      }                                                                                                                                              
      if (updates.role) { fieldsToUpdate.role = updates.role; updatedFields.push(`cargo: ${updates.role}`); }                                        
      if (updates.employees) { fieldsToUpdate.employees = updates.employees; updatedFields.push(`funcionários: ${updates.employees}`); }             
      if (updates.segment) { fieldsToUpdate.segment = updates.segment; updatedFields.push(`segmento: ${updates.segment}`); }                         
                                                                                                                                                     
      // Cidade/Estado/Timezone                                                                                                                      
      if (updates.cidade) {                                                                                                                          
        fieldsToUpdate.cidade = updates.cidade;                                                                                                      
        updatedFields.push(`cidade: ${updates.cidade}`);                                                                                             
        const detectedTimezone = detectTimezoneFromCity(updates.cidade);                                                                             
        if (detectedTimezone) {                                                                                                                      
          fieldsToUpdate.timezone = detectedTimezone;                                                                                                
          updatedFields.push(`timezone: ${getTimezoneFriendlyName(detectedTimezone)}`);                                                              
        }                                                                                                                                            
      }                                                                                                                                              
      if (updates.estado) {                                                                                                                          
        fieldsToUpdate.estado = updates.estado;                                                                                                      
        updatedFields.push(`estado: ${updates.estado}`);                                                                                             
        if (!fieldsToUpdate.timezone) {                                                                                                              
          const detectedTimezone = detectTimezoneFromCity(updates.estado);                                                                           
          if (detectedTimezone) {                                                                                                                    
            fieldsToUpdate.timezone = detectedTimezone;                                                                                              
            updatedFields.push(`timezone: ${getTimezoneFriendlyName(detectedTimezone)}`);                                                            
          }                                                                                                                                          
        }                                                                                                                                            
      }                                                                                                                                              
                                                                                                                                                     
      if (updates.notes) {                                                                                                                           
        const existingNotes = context.lead.notes || '';                                                                                              
        const timestamp = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });                                                     
        fieldsToUpdate.notes = existingNotes ? `${existingNotes}\n\n[${timestamp}] ${updates.notes}` : `[${timestamp}] ${updates.notes}`;            
        updatedFields.push('notas adicionadas');                                                                                                     
      }                                                                                                                                              
                                                                                                                                                     
      if (Object.keys(fieldsToUpdate).length === 0) {                                                                                                
        return { success: true, message: 'Nenhuma informação nova para atualizar.', data: { updated: false }, nextAction: 'continue' };              
      }                                                                                                                                              
                                                                                                                                                     
      try {                                                                                                                                          
        await leadsRepository.update(context.organizationId, context.leadId, fieldsToUpdate);                                                        
        return { success: true, message: `Informações atualizadas: ${updatedFields.join(', ')}`, data: { updated: true, fields:                      
  Object.keys(fieldsToUpdate) }, nextAction: 'continue' };                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  // ============================================================================                                                                    
  // EXTRACT LEAD INFO TOOL                                                                                                                          
  // ============================================================================                                                                    
                                                                                                                                                     
  export const extractLeadInfoInputSchema = z.object({                                                                                               
    extractedInfo: z.object({                                                                                                                        
      name: z.string().optional(),                                                                                                                   
      email: z.string().optional(),                                                                                                                  
      phone: z.string().optional(),                                                                                                                  
      company: z.string().optional(),                                                                                                                
      role: z.string().optional(),                                                                                                                   
      employees: z.number().optional(),                                                                                                              
      cidade: z.string().optional(),                                                                                                                 
      estado: z.string().optional(),                                                                                                                 
      whatsappVolume: z.string().optional(),                                                                                                         
      interests: z.array(z.string()).optional(),                                                                                                     
      painPoints: z.array(z.string()).optional(),                                                                                                    
      budget: z.string().optional(),                                                                                                                 
      timeline: z.string().optional(),                                                                                                               
    }),                                                                                                                                              
  });                                                                                                                                                
                                                                                                                                                     
  export type ExtractLeadInfoInput = z.infer<typeof extractLeadInfoInputSchema>;                                                                     
                                                                                                                                                     
  export const extractLeadInfoTool: Tool = {                                                                                                         
    name: TOOL_NAMES.EXTRACT_LEAD_INFO,                                                                                                              
    description: `Extrai e salva informações do lead mencionadas na conversa automaticamente.`,                                                      
                                                                                                                                                     
    inputSchema: extractLeadInfoInputSchema,                                                                                                         
    requiresConfirmation: false,                                                                                                                     
    timeout: 10000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = extractLeadInfoInputSchema.safeParse(input);                                                                                    
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { extractedInfo } = parsed.data;                                                                                                         
                                                                                                                                                     
      try {                                                                                                                                          
        const updates: Record<string, unknown> = {};                                                                                                 
        const extracted: string[] = [];                                                                                                              
                                                                                                                                                     
        if (extractedInfo.name && extractedInfo.name !== context.lead.name) { updates.name = extractedInfo.name; extracted.push('nome'); }           
        if (extractedInfo.email && extractedInfo.email !== context.lead.email) { updates.email = extractedInfo.email; extracted.push('email'); }     
        if (extractedInfo.phone && extractedInfo.phone !== context.lead.phone) { updates.phone = extractedInfo.phone; extracted.push('telefone'); }  
        if (extractedInfo.company && extractedInfo.company !== context.lead.company) { updates.company = extractedInfo.company;                      
  extracted.push('empresa'); }                                                                                                                       
        if (extractedInfo.role) { updates.role = extractedInfo.role; extracted.push('cargo'); }                                                      
        if (extractedInfo.employees) { updates.employees = extractedInfo.employees; extracted.push('funcionários'); }                                
                                                                                                                                                     
        if (extractedInfo.cidade) {                                                                                                                  
          updates.cidade = extractedInfo.cidade;                                                                                                     
          extracted.push('cidade');                                                                                                                  
          const detectedTimezone = detectTimezoneFromCity(extractedInfo.cidade);                                                                     
          if (detectedTimezone) {                                                                                                                    
            updates.timezone = detectedTimezone;                                                                                                     
            extracted.push(`timezone (${getTimezoneFriendlyName(detectedTimezone)})`);                                                               
          }                                                                                                                                          
        }                                                                                                                                            
        if (extractedInfo.estado) {                                                                                                                  
          updates.estado = extractedInfo.estado;                                                                                                     
          extracted.push('estado');                                                                                                                  
          if (!updates.timezone) {                                                                                                                   
            const detectedTimezone = detectTimezoneFromCity(extractedInfo.estado);                                                                   
            if (detectedTimezone) {                                                                                                                  
              updates.timezone = detectedTimezone;                                                                                                   
              extracted.push(`timezone (${getTimezoneFriendlyName(detectedTimezone)})`);                                                             
            }                                                                                                                                        
          }                                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        // Info adicional nas notas                                                                                                                  
        const additionalInfo: string[] = [];                                                                                                         
        if (extractedInfo.whatsappVolume) additionalInfo.push(`Volume WhatsApp: ${extractedInfo.whatsappVolume}`);                                   
        if (extractedInfo.interests?.length) additionalInfo.push(`Interesses: ${extractedInfo.interests.join(', ')}`);                               
        if (extractedInfo.painPoints?.length) additionalInfo.push(`Dores: ${extractedInfo.painPoints.join(', ')}`);                                  
        if (extractedInfo.budget) additionalInfo.push(`Orçamento: ${extractedInfo.budget}`);                                                         
        if (extractedInfo.timeline) additionalInfo.push(`Timeline: ${extractedInfo.timeline}`);                                                      
                                                                                                                                                     
        if (additionalInfo.length > 0) {                                                                                                             
          const existingNotes = context.lead.notes || '';                                                                                            
          const timestamp = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });                                                   
          updates.notes = existingNotes                                                                                                              
            ? `${existingNotes}\n\n[${timestamp} - Auto-extracted]\n${additionalInfo.join('\n')}`                                                    
            : `[${timestamp} - Auto-extracted]\n${additionalInfo.join('\n')}`;                                                                       
          extracted.push('informações adicionais');                                                                                                  
        }                                                                                                                                            
                                                                                                                                                     
        if (Object.keys(updates).length > 0) {                                                                                                       
          await leadsRepository.update(context.organizationId, context.leadId, updates);                                                             
        }                                                                                                                                            
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: extracted.length > 0 ? `Informações extraídas: ${extracted.join(', ')}` : 'Nenhuma informação nova.',                             
          data: { extracted: extracted.length > 0, fields: extracted },                                                                              
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 19: tools/qualify-lead.tool.ts (293 linhas)                                                                                                  
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import { leadsRepository, BANT, FIT } from '../../../services/supabase/repositories';                                                              
  import { LeadStatus } from '../../../services/supabase/types';                                                                                     
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const qualifyLeadInputSchema = z.object({                                                                                                   
    bant: z.object({                                                                                                                                 
      budget: z.number().min(0).max(5).describe('Orçamento (0-5)'),                                                                                  
      authority: z.number().min(0).max(5).describe('Autoridade (0-5)'),                                                                              
      need: z.number().min(0).max(5).describe('Necessidade (0-5)'),                                                                                  
      timing: z.number().min(0).max(5).describe('Timing (0-5)'),                                                                                     
    }),                                                                                                                                              
    fit: z.object({                                                                                                                                  
      porte: z.number().min(0).max(5).describe('Porte da empresa (0-5)'),                                                                            
      volume_whatsapp: z.number().min(0).max(5).describe('Volume WhatsApp (0-5)'),                                                                   
      maturidade_digital: z.number().min(0).max(5).describe('Maturidade digital (0-5)'),                                                             
      potencial_crescimento: z.number().min(0).max(5).describe('Potencial de crescimento (0-5)'),                                                    
    }),                                                                                                                                              
    reasoning: z.string().optional().describe('Justificativa para as pontuações'),                                                                   
  });                                                                                                                                                
                                                                                                                                                     
  export type QualifyLeadInput = z.infer<typeof qualifyLeadInputSchema>;                                                                             
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPER FUNCTIONS                                                                                                                                
  // ============================================================================                                                                    
                                                                                                                                                     
  function calculateLeadClassification(bantTotal: number, fitTotal: number): {                                                                       
    classification: 'quente' | 'morno' | 'frio';                                                                                                     
    pipelineStep: string;                                                                                                                            
    status: LeadStatus;                                                                                                                              
    priority: number;                                                                                                                                
  } {                                                                                                                                                
    const totalScore = bantTotal + fitTotal; // Max: 40                                                                                              
    if (totalScore >= 32) return { classification: 'quente', pipelineStep: 'qualificado', status: LeadStatus.OPEN, priority: 1 };                    
    if (totalScore >= 20) return { classification: 'morno', pipelineStep: 'qualificado', status: LeadStatus.OPEN, priority: 2 };                     
    return { classification: 'frio', pipelineStep: 'contatado', status: LeadStatus.OPEN, priority: 3 };                                              
  }                                                                                                                                                  
                                                                                                                                                     
  function generateRecommendations(bant: BANT, fit: FIT): string[] {                                                                                 
    const recommendations: string[] = [];                                                                                                            
    if (bant.budget < 3) recommendations.push('Explorar orçamento e opções de pagamento');                                                           
    if (bant.authority < 3) recommendations.push('Identificar o decisor');                                                                           
    if (bant.need < 3) recommendations.push('Aprofundar descoberta de dores');                                                                       
    if (bant.timing < 3) recommendations.push('Criar urgência');                                                                                     
    if (fit.porte < 3) recommendations.push('Avaliar adequação do porte');                                                                           
    if (fit.volume_whatsapp < 3) recommendations.push('Apresentar benefícios para baixo volume');                                                    
    if (fit.maturidade_digital < 3) recommendations.push('Oferecer suporte na implementação');                                                       
    return recommendations;                                                                                                                          
  }                                                                                                                                                  
                                                                                                                                                     
  function formatScoreBar(score: number, max: number = 5): string {                                                                                  
    return `${'█'.repeat(score)}${'░'.repeat(max - score)} ${score}/${max}`;                                                                         
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const qualifyLeadTool: Tool = {                                                                                                             
    name: TOOL_NAMES.QUALIFY_LEAD,                                                                                                                   
    description: `Qualifica o lead usando metodologia BANT e FIT.                                                                                    
  BANT: Budget, Authority, Need, Timing (0-5 cada)                                                                                                   
  FIT: Porte, Volume WhatsApp, Maturidade Digital, Potencial (0-5 cada)`,                                                                            
                                                                                                                                                     
    inputSchema: qualifyLeadInputSchema,                                                                                                             
    requiresConfirmation: false,                                                                                                                     
    timeout: 10000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = qualifyLeadInputSchema.safeParse(input);                                                                                        
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { bant, fit, reasoning } = parsed.data;                                                                                                  
                                                                                                                                                     
      try {                                                                                                                                          
        const bantTotal = bant.budget + bant.authority + bant.need + bant.timing;                                                                    
        const fitTotal = fit.porte + fit.volume_whatsapp + fit.maturidade_digital + fit.potencial_crescimento;                                       
        const classification = calculateLeadClassification(bantTotal, fitTotal);                                                                     
        const recommendations = generateRecommendations(bant, fit);                                                                                  
                                                                                                                                                     
        await leadsRepository.updateQualification(                                                                                                   
          context.organizationId, context.leadId,                                                                                                    
          bant, fit, classification.pipelineStep, classification.status                                                                              
        );                                                                                                                                           
                                                                                                                                                     
        if (reasoning) {                                                                                                                             
          const existingNotes = context.lead.notes || '';                                                                                            
          const timestamp = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });                                                   
          await leadsRepository.update(context.organizationId, context.leadId, {                                                                     
            notes: existingNotes ? `${existingNotes}\n\n[${timestamp} - Qualificação]\n${reasoning}` : `[${timestamp} - Qualificação]\n${reasoning}`,
          });                                                                                                                                        
        }                                                                                                                                            
                                                                                                                                                     
        const scoreReport = [                                                                                                                        
          '=== BANT ===',                                                                                                                            
          `Budget:    ${formatScoreBar(bant.budget)}`,                                                                                               
          `Authority: ${formatScoreBar(bant.authority)}`,                                                                                            
          `Need:      ${formatScoreBar(bant.need)}`,                                                                                                 
          `Timing:    ${formatScoreBar(bant.timing)}`,                                                                                               
          `Total BANT: ${bantTotal}/20`,                                                                                                             
          '',                                                                                                                                        
          '=== FIT ===',                                                                                                                             
          `Porte:              ${formatScoreBar(fit.porte)}`,                                                                                        
          `Volume WhatsApp:    ${formatScoreBar(fit.volume_whatsapp)}`,                                                                              
          `Maturidade Digital: ${formatScoreBar(fit.maturidade_digital)}`,                                                                           
          `Potencial:          ${formatScoreBar(fit.potencial_crescimento)}`,                                                                        
          `Total FIT: ${fitTotal}/20`,                                                                                                               
          '',                                                                                                                                        
          `=== ${classification.classification.toUpperCase()} ===`,                                                                                  
        ].join('\n');                                                                                                                                
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: `Lead qualificado como ${classification.classification.toUpperCase()}`,                                                           
          data: {                                                                                                                                    
            bant: { ...bant, total: bantTotal, percentage: Math.round((bantTotal / 20) * 100) },                                                     
            fit: { ...fit, total: fitTotal, percentage: Math.round((fitTotal / 20) * 100) },                                                         
            overall: { total: bantTotal + fitTotal, percentage: Math.round(((bantTotal + fitTotal) / 40) * 100) },                                   
            classification: classification.classification,                                                                                           
            recommendations,                                                                                                                         
            report: scoreReport,                                                                                                                     
          },                                                                                                                                         
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 20: tools/detect-timezone.tool.ts (310 linhas)                                                                                               
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext } from '../tool-router';                                                                                                
  import { ToolResult } from '../types';                                                                                                             
  import { timezonesRepository, dynamicRepository } from '../../../services/supabase/repositories';                                                  
  import { getTimezoneFriendlyName, getTimezoneOffsetDifference, isSameTimezone } from '../../../utils/timezone';                                    
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const detectTimezoneInputSchema = z.object({                                                                                                
    cidade: z.string().describe('Cidade ou estado que o lead informou (ex: "SP", "Cuiabá", "Manaus")'),                                              
  });                                                                                                                                                
                                                                                                                                                     
  export type DetectTimezoneInput = z.infer<typeof detectTimezoneInputSchema>;                                                                       
                                                                                                                                                     
  // ============================================================================                                                                    
  // HELPERS                                                                                                                                         
  // ============================================================================                                                                    
                                                                                                                                                     
  function isTimezoneDetectionDisabled(systemPrompt: string | undefined): boolean {                                                                  
    if (!systemPrompt) return false;                                                                                                                 
    const normalizedPrompt = systemPrompt.toLowerCase();                                                                                             
    const disablePatterns = [                                                                                                                        
      'não pergunte o fuso', 'nao pergunte fuso', 'todos os leads falam do',                                                                         
      'assume timezone', 'timezone fixo', 'fuso fixo', 'mesmo fuso',                                                                                 
    ];                                                                                                                                               
    return disablePatterns.some(pattern => normalizedPrompt.includes(pattern));                                                                      
  }                                                                                                                                                  
                                                                                                                                                     
  function extractDefaultTimezoneFromPrompt(systemPrompt: string | undefined): string | null {                                                       
    if (!systemPrompt) return null;                                                                                                                  
    const normalizedPrompt = systemPrompt.toLowerCase();                                                                                             
    const todosLeadsMatch = normalizedPrompt.match(/todos\s+(?:os\s+)?leads\s+falam\s+do\s+(america\/\w+)/i);                                        
    if (todosLeadsMatch) return todosLeadsMatch[1];                                                                                                  
    const fixoMatch = normalizedPrompt.match(/(?:fuso|timezone)\s+fixo[:\s]+(america\/\w+)/i);                                                       
    if (fixoMatch) return fixoMatch[1];                                                                                                              
    return null;                                                                                                                                     
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const detectTimezoneTool: Tool = {                                                                                                          
    name: 'detect_lead_timezone',                                                                                                                    
    description: `Detecta o fuso horário do lead baseado na cidade/estado informado.                                                                 
                                                                                                                                                     
  🚨 OBRIGATÓRIO: Chame IMEDIATAMENTE quando o lead informar de onde está.                                                                           
                                                                                                                                                     
  Exemplos:                                                                                                                                          
  - "sou de SP" → { cidade: "SP" }                                                                                                                   
  - "estou em Cuiabá" → { cidade: "Cuiabá" }                                                                                                         
  - "falo de Manaus" → { cidade: "Manaus" }                                                                                                          
                                                                                                                                                     
  Retorna o timezone detectado e diferença de horário.`,                                                                                             
                                                                                                                                                     
    inputSchema: detectTimezoneInputSchema,                                                                                                          
    requiresConfirmation: false,                                                                                                                     
    timeout: 5000,                                                                                                                                   
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = detectTimezoneInputSchema.safeParse(input);                                                                                     
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { cidade } = parsed.data;                                                                                                                
      const agentTimezone = context.agentConfig.timezone || 'America/Sao_Paulo';                                                                     
      const systemPrompt = context.agentConfig.system_prompt;                                                                                        
                                                                                                                                                     
      try {                                                                                                                                          
        // Verificar se desabilitado via prompt                                                                                                      
        if (isTimezoneDetectionDisabled(systemPrompt)) {                                                                                             
          const promptTimezone = extractDefaultTimezoneFromPrompt(systemPrompt);                                                                     
          const defaultTimezone = promptTimezone || agentTimezone;                                                                                   
          const timezoneName = getTimezoneFriendlyName(defaultTimezone);                                                                             
                                                                                                                                                     
          const tableLeads = context.agentConfig.table_leads;                                                                                        
          if (tableLeads) {                                                                                                                          
            await dynamicRepository.updateLeadByRemoteJid(tableLeads, context.remoteJid, {                                                           
              cidade, timezone: defaultTimezone,                                                                                                     
            });                                                                                                                                      
          }                                                                                                                                          
                                                                                                                                                     
          return {                                                                                                                                   
            success: true,                                                                                                                           
            message: `Timezone configurado como ${timezoneName} (padrão). Não há necessidade de conversão.`,                                         
            data: { detected: true, leadTimezone: defaultTimezone, isSameTimezone: true, disabledByPrompt: true },                                   
            nextAction: 'continue',                                                                                                                  
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        // Detectar via tabela brazil_timezones                                                                                                      
        const detection = await timezonesRepository.detectTimezone(cidade);                                                                          
                                                                                                                                                     
        if (!detection.found || !detection.timezone) {                                                                                               
          return {                                                                                                                                   
            success: false,                                                                                                                          
            message: `Não consegui identificar o fuso de "${cidade}". Pode me dizer o estado (ex: SP, MG, RJ)?`,                                     
            data: { detected: false, inputCity: cidade },                                                                                            
            nextAction: 'continue',                                                                                                                  
          };                                                                                                                                         
        }                                                                                                                                            
                                                                                                                                                     
        const detectedTimezone = detection.timezone;                                                                                                 
        const timezoneName = detection.timezone_friendly || getTimezoneFriendlyName(detectedTimezone);                                               
        const agentTimezoneName = getTimezoneFriendlyName(agentTimezone);                                                                            
        const sameFuso = isSameTimezone(detectedTimezone, agentTimezone);                                                                            
        const diffMinutes = getTimezoneOffsetDifference(agentTimezone, detectedTimezone);                                                            
        const diffHours = diffMinutes / 60;                                                                                                          
                                                                                                                                                     
        // Salvar no lead                                                                                                                            
        const tableLeads = context.agentConfig.table_leads;                                                                                          
        if (tableLeads) {                                                                                                                            
          await dynamicRepository.updateLeadByRemoteJid(tableLeads, context.remoteJid, {                                                             
            cidade, timezone: detectedTimezone,                                                                                                      
          });                                                                                                                                        
        }                                                                                                                                            
                                                                                                                                                     
        let infoMessage: string;                                                                                                                     
        let conversionExample: string;                                                                                                               
                                                                                                                                                     
        if (sameFuso) {                                                                                                                              
          infoMessage = `Lead em ${detection.state_name} (${timezoneName}) - MESMO FUSO. Não precisa converter horários.`;                           
          conversionExample = 'Se você oferecer 10h, o lead entende 10h.';                                                                           
        } else if (diffHours > 0) {                                                                                                                  
          infoMessage = `Lead em ${detection.state_name} (${timezoneName}) - ${Math.abs(diffHours)}h A MENOS que ${agentTimezoneName}.`;             
          conversionExample = `Se calendário tem 10h, para o lead são ${10 - Math.abs(diffHours)}h.`;                                                
        } else {                                                                                                                                     
          infoMessage = `Lead em ${detection.state_name} (${timezoneName}) - ${Math.abs(diffHours)}h A MAIS que ${agentTimezoneName}.`;              
          conversionExample = `Se calendário tem 10h, para o lead são ${10 + Math.abs(diffHours)}h.`;                                                
        }                                                                                                                                            
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: infoMessage,                                                                                                                      
          data: {                                                                                                                                    
            detected: true,                                                                                                                          
            inputCity: cidade,                                                                                                                       
            leadTimezone: detectedTimezone,                                                                                                          
            leadTimezoneName: timezoneName,                                                                                                          
            leadState: detection.state_name,                                                                                                         
            calendarTimezone: agentTimezone,                                                                                                         
            isSameTimezone: sameFuso,                                                                                                                
            differenceHours: diffHours,                                                                                                              
            conversionNote: conversionExample,                                                                                                       
            instructions: sameFuso                                                                                                                   
              ? 'Use os horários diretamente.'                                                                                                       
              : `IMPORTANTE: Informe horários no FUSO DO LEAD (${timezoneName}). Sistema converte automaticamente.`,                                 
          },                                                                                                                                         
          nextAction: 'continue',                                                                                                                    
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 21: tools/process-customer-intent.tool.ts (360 linhas)                                                                                       
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext } from '../tool-router';                                                                                                
  import { ToolResult } from '../types';                                                                                                             
                                                                                                                                                     
  import { scheduleInquiryTool, ScheduleInquiryInput } from './schedule-inquiry.tool';                                                               
  import { scheduleConfirmationTool, ScheduleConfirmationInput } from './schedule-confirmation.tool';                                                
  import { paymentLinkTool, PaymentLinkInput } from './payment-link.tool';                                                                           
  import { humanHandoffTool, HumanHandoffInput } from './human-handoff.tool';                                                                        
  import { noInterestTool, NoInterestInput } from './no-interest.tool';                                                                              
                                                                                                                                                     
  // ============================================================================                                                                    
  // DEPARTMENT IDS                                                                                                                                  
  // ============================================================================                                                                    
                                                                                                                                                     
  export const DEPARTMENT_IDS = {                                                                                                                    
    suporte: '459', financeiro: '460', implantacao: '461', vendas: '462', comercial: '463',                                                          
  } as const;                                                                                                                                        
                                                                                                                                                     
  export type DepartmentName = keyof typeof DEPARTMENT_IDS;                                                                                          
  export type DepartmentId = (typeof DEPARTMENT_IDS)[DepartmentName];                                                                                
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMAS                                                                                                                                   
  // ============================================================================                                                                    
                                                                                                                                                     
  const schedulingDataSchema = z.object({                                                                                                            
    date: z.string().optional(),                                                                                                                     
    time: z.string().optional(),                                                                                                                     
    duration_minutes: z.number().optional().default(30),                                                                                             
    summary: z.string().optional(),                                                                                                                  
    client_name: z.string().optional(),                                                                                                              
    client_phone: z.string().optional(),                                                                                                             
  });                                                                                                                                                
                                                                                                                                                     
  const paymentDataSchema = z.object({                                                                                                               
    amount: z.number().positive().optional(),                                                                                                        
    description: z.string().optional(),                                                                                                              
    due_date: z.string().optional(),                                                                                                                 
    billing_type: z.enum(['BOLETO', 'PIX', 'CREDIT_CARD', 'UNDEFINED']).optional(),                                                                  
    max_installments: z.number().min(1).max(12).optional(),                                                                                          
  });                                                                                                                                                
                                                                                                                                                     
  const handoffDataSchema = z.object({                                                                                                               
    department_id: z.enum(['459', '460', '461', '462', '463']).optional(),                                                                           
    department: z.enum(['suporte', 'financeiro', 'implantacao', 'vendas', 'comercial']).optional(),                                                  
    reason: z.string(),                                                                                                                              
    priority: z.enum(['low', 'medium', 'high', 'urgent']).optional().default('medium'),                                                              
    summary: z.string().optional(),                                                                                                                  
  });                                                                                                                                                
                                                                                                                                                     
  const noInterestDataSchema = z.object({                                                                                                            
    reason: z.string(),                                                                                                                              
    category: z.enum(['price', 'timing', 'competitor', 'no_need', 'no_fit', 'other']).optional().default('other'),                                   
    recontact: z.boolean().optional().default(true),                                                                                                 
    recontact_days: z.number().optional().default(30),                                                                                               
    feedback: z.string().optional(),                                                                                                                 
  });                                                                                                                                                
                                                                                                                                                     
  export const processCustomerIntentInputSchema = z.object({                                                                                         
    intent_type: z.enum([                                                                                                                            
      'schedule_inquiry', 'schedule_confirmation', 'payment_link_request', 'human_handoff', 'no_interest_detected',                                  
    ]).describe('Tipo de intenção do cliente'),                                                                                                      
    context_data: z.object({                                                                                                                         
      scheduling_data: schedulingDataSchema.optional(),                                                                                              
      payment_data: paymentDataSchema.optional(),                                                                                                    
      handoff_data: handoffDataSchema.optional(),                                                                                                    
      no_interest_data: noInterestDataSchema.optional(),                                                                                             
    }).optional(),                                                                                                                                   
  });                                                                                                                                                
                                                                                                                                                     
  export type ProcessCustomerIntentInput = z.infer<typeof processCustomerIntentInputSchema>;                                                         
                                                                                                                                                     
  // ============================================================================                                                                    
  // MAPPERS                                                                                                                                         
  // ============================================================================                                                                    
                                                                                                                                                     
  function getDepartmentName(departmentId?: string): string | undefined {                                                                            
    const mapping: Record<string, string> = { '459': 'suporte', '460': 'financeiro', '461': 'implantação', '462': 'vendas', '463': 'comercial' };    
    return departmentId ? mapping[departmentId] : undefined;                                                                                         
  }                                                                                                                                                  
                                                                                                                                                     
  function mapToScheduleInquiryInput(data?: z.infer<typeof schedulingDataSchema>): ScheduleInquiryInput {                                            
    return { date: data?.date, duration: data?.duration_minutes || 30, daysAhead: 5 };                                                               
  }                                                                                                                                                  
                                                                                                                                                     
  function mapToScheduleConfirmationInput(data?: z.infer<typeof schedulingDataSchema>, context?: ToolContext): ScheduleConfirmationInput {           
    return {                                                                                                                                         
      date: data?.date || '', time: data?.time || '', duration: data?.duration_minutes || 30,                                                        
      title: data?.summary || `Reunião com ${data?.client_name || context?.lead?.name || 'Cliente'}`,                                                
      description: `Agendamento via WhatsApp\nCliente: ${data?.client_name || ''}\nTelefone: ${data?.client_phone || ''}`,                           
      createMeetLink: true, sendNotification: true,                                                                                                  
    };                                                                                                                                               
  }                                                                                                                                                  
                                                                                                                                                     
  function mapToPaymentLinkInput(data?: z.infer<typeof paymentDataSchema>): PaymentLinkInput {                                                       
    return { value: data?.amount || 0, description: data?.description || 'Pagamento', billingType: data?.billing_type || 'UNDEFINED', dueDate:       
  data?.due_date, maxInstallments: data?.max_installments || 1, expirationDays: 7 };                                                                 
  }                                                                                                                                                  
                                                                                                                                                     
  function mapToHumanHandoffInput(data?: z.infer<typeof handoffDataSchema>): HumanHandoffInput {                                                     
    return { reason: data?.reason || 'Solicitação de atendimento humano', priority: data?.priority || 'medium', department: data?.department ||      
  getDepartmentName(data?.department_id), summary: data?.summary, customerSentiment: 'neutral' };                                                    
  }                                                                                                                                                  
                                                                                                                                                     
  function mapToNoInterestInput(data?: z.infer<typeof noInterestDataSchema>): NoInterestInput {                                                      
    return { reason: data?.reason || 'Sem interesse', category: data?.category || 'other', recontact: data?.recontact ?? true, recontactDays:        
  data?.recontact_days || 30, feedback: data?.feedback };                                                                                            
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const processCustomerIntentTool: Tool = {                                                                                                   
    name: 'process_customer_intent',                                                                                                                 
    description: `Processa a intenção do cliente de forma unificada (formato Leadbox/N8N).                                                           
                                                                                                                                                     
  TIPOS DE INTENÇÃO:                                                                                                                                 
  - schedule_inquiry: Ver horários disponíveis                                                                                                       
  - schedule_confirmation: Confirmar agendamento                                                                                                     
  - payment_link_request: Gerar link de pagamento                                                                                                    
  - human_handoff: Transferir para humano                                                                                                            
  - no_interest_detected: Registrar sem interesse                                                                                                    
                                                                                                                                                     
  DEPARTAMENTOS (para handoff):                                                                                                                      
  - 459 ou "suporte"                                                                                                                                 
  - 460 ou "financeiro"                                                                                                                              
  - 461 ou "implantacao"                                                                                                                             
  - 462 ou "vendas"                                                                                                                                  
  - 463 ou "comercial"`,                                                                                                                             
                                                                                                                                                     
    inputSchema: processCustomerIntentInputSchema,                                                                                                   
    requiresConfirmation: false,                                                                                                                     
    timeout: 25000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = processCustomerIntentInputSchema.safeParse(input);                                                                              
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { intent_type, context_data } = parsed.data;                                                                                             
                                                                                                                                                     
      try {                                                                                                                                          
        switch (intent_type) {                                                                                                                       
          case 'schedule_inquiry':                                                                                                                   
            return await scheduleInquiryTool.execute(mapToScheduleInquiryInput(context_data?.scheduling_data), context);                             
                                                                                                                                                     
          case 'schedule_confirmation': {                                                                                                            
            const confirmationInput = mapToScheduleConfirmationInput(context_data?.scheduling_data, context);                                        
            if (!confirmationInput.date || !confirmationInput.time) {                                                                                
              return { success: false, message: 'Para confirmar, preciso da data e horário.', data: { missingFields: ['date', 'time'] }, nextAction: 
  'continue' };                                                                                                                                      
            }                                                                                                                                        
            return await scheduleConfirmationTool.execute(confirmationInput, context);                                                               
          }                                                                                                                                          
                                                                                                                                                     
          case 'payment_link_request': {                                                                                                             
            const paymentInput = mapToPaymentLinkInput(context_data?.payment_data);                                                                  
            if (!paymentInput.value || paymentInput.value <= 0) {                                                                                    
              return { success: false, message: 'Para gerar o link, preciso saber o valor.', data: { missingFields: ['amount'] }, nextAction:        
  'continue' };                                                                                                                                      
            }                                                                                                                                        
            return await paymentLinkTool.execute(paymentInput, context);                                                                             
          }                                                                                                                                          
                                                                                                                                                     
          case 'human_handoff': {                                                                                                                    
            const handoffInput = mapToHumanHandoffInput(context_data?.handoff_data);                                                                 
            const result = await humanHandoffTool.execute(handoffInput, context);                                                                    
            if (result.success && result.data) {                                                                                                     
              result.data.department_id = context_data?.handoff_data?.department_id || DEPARTMENT_IDS[handoffInput.department as DepartmentName];    
            }                                                                                                                                        
            return result;                                                                                                                           
          }                                                                                                                                          
                                                                                                                                                     
          case 'no_interest_detected':                                                                                                               
            return await noInterestTool.execute(mapToNoInterestInput(context_data?.no_interest_data), context);                                      
                                                                                                                                                     
          default:                                                                                                                                   
            return { success: false, message: `Tipo de intenção não reconhecido: ${intent_type}`, nextAction: 'continue' };                          
        }                                                                                                                                            
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  export type { ProcessCustomerIntentInput, DepartmentName, DepartmentId };                                                                          
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 22: tools/send-voice-message.tool.ts (257 linhas)                                                                                            
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import { agentsRepository } from '../../../services/supabase/repositories/agents.repository';                                                      
  import { createElevenLabsClient } from '../../../services/elevenlabs';                                                                             
  import { UazapiClient } from '../../../services/uazapi';                                                                                           
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const sendVoiceMessageInputSchema = z.object({                                                                                              
    message: z.string().min(1).max(5000).describe('Texto que será convertido em áudio (max 5000 chars)'),                                            
    stability: z.number().min(0).max(1).optional().default(0.5).describe('Estabilidade da voz (0-1)'),                                               
    similarity_boost: z.number().min(0).max(1).optional().default(0.75).describe('Boost de similaridade (0-1)'),                                     
  });                                                                                                                                                
                                                                                                                                                     
  export type SendVoiceMessageInput = z.infer<typeof sendVoiceMessageInputSchema>;                                                                   
                                                                                                                                                     
  // ============================================================================                                                                    
  // TYPES                                                                                                                                           
  // ============================================================================                                                                    
                                                                                                                                                     
  interface AgentWithVoice {                                                                                                                         
    id: string;                                                                                                                                      
    name: string;                                                                                                                                    
    uazapi_base_url: string | null;                                                                                                                  
    uazapi_token: string | null;                                                                                                                     
    elevenlabs_api_key?: string | null;                                                                                                              
    voice_clone_id?: string | null;                                                                                                                  
    voice_mode?: 'auto' | 'manual' | 'disabled';                                                                                                     
    recording_simulation?: boolean;                                                                                                                  
    recording_delay?: number;                                                                                                                        
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const sendVoiceMessageTool: Tool = {                                                                                                        
    name: TOOL_NAMES.SEND_VOICE_MESSAGE,                                                                                                             
    description: `Envia uma mensagem de voz usando o clone de voz do agente via ElevenLabs.                                                          
                                                                                                                                                     
  Use quando:                                                                                                                                        
  - Cliente preferir ouvir ao invés de ler                                                                                                           
  - Mensagem for longa e melhor como áudio                                                                                                           
  - Quiser criar conexão mais pessoal                                                                                                                
  - Cliente solicitar áudio                                                                                                                          
  - Saudação inicial mais calorosa                                                                                                                   
  - Cliente enviou áudio e quer responder no mesmo formato                                                                                           
                                                                                                                                                     
  IMPORTANTE:                                                                                                                                        
  - Limite de 5000 caracteres                                                                                                                        
  - Use linguagem natural e conversacional                                                                                                           
  - Evite emojis e formatação markdown                                                                                                               
  - Escreva como se estivesse falando`,                                                                                                              
                                                                                                                                                     
    inputSchema: sendVoiceMessageInputSchema,                                                                                                        
    requiresConfirmation: false,                                                                                                                     
    timeout: 45000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = sendVoiceMessageInputSchema.safeParse(input);                                                                                   
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const { message, stability, similarity_boost } = parsed.data;                                                                                  
                                                                                                                                                     
      try {                                                                                                                                          
        const agentId = context.agentConfig?.id;                                                                                                     
        if (!agentId) return { success: false, message: 'ID do agente não encontrado', nextAction: 'continue' };                                     
                                                                                                                                                     
        const agent = await agentsRepository.findById(agentId) as AgentWithVoice | null;                                                             
        if (!agent) return { success: false, message: 'Agente não encontrado', nextAction: 'continue' };                                             
                                                                                                                                                     
        const elevenlabsApiKey = agent.elevenlabs_api_key;                                                                                           
        const voiceCloneId = agent.voice_clone_id;                                                                                                   
                                                                                                                                                     
        if (!elevenlabsApiKey) return { success: false, message: 'ElevenLabs não configurado. Use texto.', nextAction: 'continue' };                 
        if (!voiceCloneId) return { success: false, message: 'Clone de voz não configurado. Use texto.', nextAction: 'continue' };                   
        if (!agent.uazapi_base_url || !agent.uazapi_token) return { success: false, message: 'UAZAPI não configurado', nextAction: 'continue' };     
                                                                                                                                                     
        // Gerar áudio com ElevenLabs                                                                                                                
        const elevenLabsClient = createElevenLabsClient({ apiKey: elevenlabsApiKey });                                                               
        const audioBase64 = await elevenLabsClient.textToSpeechBase64({                                                                              
          text: message,                                                                                                                             
          voice_id: voiceCloneId,                                                                                                                    
          voice_settings: { stability: stability ?? 0.5, similarity_boost: similarity_boost ?? 0.75 },                                               
        });                                                                                                                                          
                                                                                                                                                     
        // Enviar via UAZAPI                                                                                                                         
        const uazapiClient = new UazapiClient({ baseUrl: agent.uazapi_base_url, instanceToken: agent.uazapi_token });                                
        const recordingSimulation = agent.recording_simulation !== false;                                                                            
        const recordingDelay = recordingSimulation ? (agent.recording_delay || 15000) : 0;                                                           
                                                                                                                                                     
        const audioDataUrl = `data:audio/mpeg;base64,${audioBase64}`;                                                                                
        let useNativeDelay = false;                                                                                                                  
                                                                                                                                                     
        if (recordingSimulation && recordingDelay > 0) {                                                                                             
          const presenceSent = await uazapiClient.sendPresence(context.remoteJid, 'recording');                                                      
          if (presenceSent) {                                                                                                                        
            await new Promise(resolve => setTimeout(resolve, recordingDelay));                                                                       
            useNativeDelay = false;                                                                                                                  
          } else {                                                                                                                                   
            useNativeDelay = true;                                                                                                                   
          }                                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        await uazapiClient.sendAudio(context.remoteJid, audioDataUrl, true, useNativeDelay ? recordingDelay : 0);                                    
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: 'Mensagem de voz enviada com sucesso',                                                                                            
          data: { textLength: message.length, voiceId: voiceCloneId, audioSent: true },                                                              
          nextAction: 'respond',                                                                                                                     
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}. Use texto.`, nextAction: 'continue' };          
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 23: tools/send-location.tool.ts (209 linhas)                                                                                                 
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import { agentsRepository } from '../../../services/supabase/repositories/agents.repository';                                                      
  import { UazapiClient } from '../../../services/uazapi';                                                                                           
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const sendLocationInputSchema = z.object({                                                                                                  
    latitude: z.number().min(-90).max(90).optional().describe('Latitude (-90 a 90). Se omitido, usa localização do agente.'),                        
    longitude: z.number().min(-180).max(180).optional().describe('Longitude (-180 a 180). Se omitido, usa localização do agente.'),                  
    name: z.string().max(100).optional().describe('Nome do local'),                                                                                  
    address: z.string().max(500).optional().describe('Endereço completo'),                                                                           
  });                                                                                                                                                
                                                                                                                                                     
  export type SendLocationInput = z.infer<typeof sendLocationInputSchema>;                                                                           
                                                                                                                                                     
  // ============================================================================                                                                    
  // TYPES                                                                                                                                           
  // ============================================================================                                                                    
                                                                                                                                                     
  interface AgentWithLocation {                                                                                                                      
    id: string;                                                                                                                                      
    name: string;                                                                                                                                    
    uazapi_base_url: string | null;                                                                                                                  
    uazapi_token: string | null;                                                                                                                     
    location_latitude: number | null;                                                                                                                
    location_longitude: number | null;                                                                                                               
    location_name: string | null;                                                                                                                    
    location_address: string | null;                                                                                                                 
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const sendLocationTool: Tool = {                                                                                                            
    name: TOOL_NAMES.SEND_LOCATION,                                                                                                                  
    description: `Envia a localização do escritório/empresa para o cliente via WhatsApp.                                                             
                                                                                                                                                     
  Use quando:                                                                                                                                        
  - Cliente perguntar "onde fica?", "qual o endereço?", "como chego aí?"                                                                             
  - Precisar enviar endereço de reunião presencial                                                                                                   
  - Cliente pedir localização do estabelecimento                                                                                                     
  - Facilitar navegação do cliente até o local                                                                                                       
  - Após agendar reunião presencial                                                                                                                  
                                                                                                                                                     
  IMPORTANTE: Pode chamar SEM PARÂMETROS para usar localização configurada do agente.`,                                                              
                                                                                                                                                     
    inputSchema: sendLocationInputSchema,                                                                                                            
    requiresConfirmation: false,                                                                                                                     
    timeout: 15000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const parsed = sendLocationInputSchema.safeParse(input);                                                                                       
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos`, nextAction: 'continue' };                                       
                                                                                                                                                     
      const inputData = parsed.data;                                                                                                                 
                                                                                                                                                     
      try {                                                                                                                                          
        const agentId = context.agentConfig?.id;                                                                                                     
        if (!agentId) return { success: false, message: 'ID do agente não encontrado', nextAction: 'continue' };                                     
                                                                                                                                                     
        const agent = await agentsRepository.findById(agentId) as AgentWithLocation | null;                                                          
        if (!agent) return { success: false, message: 'Agente não encontrado', nextAction: 'continue' };                                             
        if (!agent.uazapi_base_url || !agent.uazapi_token) return { success: false, message: 'UAZAPI não configurado', nextAction: 'continue' };     
                                                                                                                                                     
        const latitude = inputData.latitude ?? agent.location_latitude;                                                                              
        const longitude = inputData.longitude ?? agent.location_longitude;                                                                           
        const name = inputData.name ?? agent.location_name ?? '';                                                                                    
        const address = inputData.address ?? agent.location_address ?? '';                                                                           
                                                                                                                                                     
        if (latitude === null || latitude === undefined || longitude === null || longitude === undefined) {                                          
          return { success: false, message: 'Localização não configurada. Configure nas configurações do agente ou passe como parâmetro.',           
  nextAction: 'continue' };                                                                                                                          
        }                                                                                                                                            
                                                                                                                                                     
        const uazapiClient = new UazapiClient({ baseUrl: agent.uazapi_base_url, instanceToken: agent.uazapi_token });                                
        await uazapiClient.sendLocation(context.remoteJid, latitude, longitude, { name, address });                                                  
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: `Localização enviada${name ? `: ${name}` : ''}`,                                                                                  
          data: { latitude, longitude, name, address, locationSent: true },                                                                          
          nextAction: 'respond',                                                                                                                     
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };                                                                                                                                                 
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 24: tools/send-contact.tool.ts (351 linhas)                                                                                                  
                                                                                                                                                     
  import { z } from 'zod';                                                                                                                           
  import { Tool, ToolContext, TOOL_NAMES } from '../tool-router';                                                                                    
  import { ToolResult } from '../types';                                                                                                             
  import { agentsRepository } from '../../../services/supabase/repositories/agents.repository';                                                      
  import { UazapiClient } from '../../../services/uazapi';                                                                                           
                                                                                                                                                     
  // ============================================================================                                                                    
  // TYPES                                                                                                                                           
  // ============================================================================                                                                    
                                                                                                                                                     
  interface ConfiguredContact {                                                                                                                      
    id?: string;                                                                                                                                     
    label?: string;                                                                                                                                  
    fullName?: string;                                                                                                                               
    phoneNumber?: string;                                                                                                                            
    name?: string;  // Legado                                                                                                                        
    phone?: string; // Legado                                                                                                                        
    organization?: string;                                                                                                                           
    email?: string;                                                                                                                                  
    url?: string;                                                                                                                                    
    trigger?: string;                                                                                                                                
  }                                                                                                                                                  
                                                                                                                                                     
  function normalizeForSearch(str: string): string {                                                                                                 
    return str.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9]/g, '').trim();                                      
  }                                                                                                                                                  
                                                                                                                                                     
  function cleanPhoneNumber(phone: string): string {                                                                                                 
    return phone.replace(/[^\d+]/g, '');                                                                                                             
  }                                                                                                                                                  
                                                                                                                                                     
  function isValidPhoneNumber(phone: string): boolean {                                                                                              
    const cleaned = cleanPhoneNumber(phone);                                                                                                         
    const digitsOnly = cleaned.replace(/\+/g, '');                                                                                                   
    return digitsOnly.length >= 10 && digitsOnly.length <= 15 && /^\+?\d+$/.test(cleaned);                                                           
  }                                                                                                                                                  
                                                                                                                                                     
  interface AgentWithContacts {                                                                                                                      
    id: string;                                                                                                                                      
    name: string;                                                                                                                                    
    uazapi_base_url: string | null;                                                                                                                  
    uazapi_token: string | null;                                                                                                                     
    crm_ghost_config?: { contacts?: ConfiguredContact[] } | null;                                                                                    
  }                                                                                                                                                  
                                                                                                                                                     
  // ============================================================================                                                                    
  // INPUT SCHEMA                                                                                                                                    
  // ============================================================================                                                                    
                                                                                                                                                     
  export const sendContactInputSchema = z.object({                                                                                                   
    contactId: z.string().optional().describe('ID ou nome do contato pré-configurado'),                                                              
    fullName: z.string().max(100).optional().describe('Nome completo (apenas se não usar contactId)'),                                               
    phoneNumber: z.string().max(20).optional().refine(val => !val || isValidPhoneNumber(val), { message: 'Número inválido. Use formato:              
  5511999999999' }).describe('Telefone (apenas se não usar contactId)'),                                                                             
    organization: z.string().max(100).optional(),                                                                                                    
    email: z.string().email().optional(),                                                                                                            
    url: z.string().url().optional(),                                                                                                                
  });                                                                                                                                                
                                                                                                                                                     
  export type SendContactInput = z.infer<typeof sendContactInputSchema>;                                                                             
                                                                                                                                                     
  // ============================================================================                                                                    
  // TOOL IMPLEMENTATION                                                                                                                             
  // ============================================================================                                                                    
                                                                                                                                                     
  export const sendContactTool: Tool = {                                                                                                             
    name: TOOL_NAMES.SEND_CONTACT,                                                                                                                   
    description: `Envia um cartão de contato (vCard) para o cliente via WhatsApp.                                                                    
                                                                                                                                                     
  Use quando:                                                                                                                                        
  - Cliente pedir "me passa o contato do Fulano"                                                                                                     
  - Cliente perguntar "qual o número do vendedor?"                                                                                                   
  - Cliente quiser salvar um número na agenda                                                                                                        
  - Após agendar reunião, enviar contato do responsável                                                                                              
                                                                                                                                                     
  COMO USAR:                                                                                                                                         
  1. Se o contato está pré-configurado: { "contactId": "nome_do_contato" }                                                                           
  2. Para contato customizado: { "fullName": "Nome", "phoneNumber": "5511999999999" }                                                                
                                                                                                                                                     
  IMPORTANTE: Sempre tente usar contactId primeiro. Se não encontrar, retornará lista de disponíveis.`,                                              
                                                                                                                                                     
    inputSchema: sendContactInputSchema,                                                                                                             
    requiresConfirmation: false,                                                                                                                     
    timeout: 15000,                                                                                                                                  
                                                                                                                                                     
    async execute(input: unknown, context: ToolContext): Promise<ToolResult> {                                                                       
      const normalizedInput = typeof input === 'object' && input !== null                                                                            
        ? {                                                                                                                                          
            contactId: (input as any).contactId || (input as any).contact_id,                                                                        
            fullName: (input as any).fullName || (input as any).full_name,                                                                           
            phoneNumber: (input as any).phoneNumber || (input as any).phone_number,                                                                  
            organization: (input as any).organization,                                                                                               
            email: (input as any).email,                                                                                                             
            url: (input as any).url,                                                                                                                 
          }                                                                                                                                          
        : input;                                                                                                                                     
                                                                                                                                                     
      const parsed = sendContactInputSchema.safeParse(normalizedInput);                                                                              
      if (!parsed.success) return { success: false, message: `Parâmetros inválidos: ${parsed.error.message}`, nextAction: 'continue' };              
                                                                                                                                                     
      const inputData = parsed.data;                                                                                                                 
                                                                                                                                                     
      try {                                                                                                                                          
        const agentId = context.agentConfig?.id;                                                                                                     
        if (!agentId) return { success: false, message: 'ID do agente não encontrado', nextAction: 'continue' };                                     
                                                                                                                                                     
        const agent = await agentsRepository.findById(agentId) as AgentWithContacts | null;                                                          
        if (!agent) return { success: false, message: 'Agente não encontrado', nextAction: 'continue' };                                             
        if (!agent.uazapi_base_url || !agent.uazapi_token) return { success: false, message: 'UAZAPI não configurado', nextAction: 'continue' };     
                                                                                                                                                     
        let fullName: string;                                                                                                                        
        let phoneNumber: string;                                                                                                                     
        let organization: string | undefined;                                                                                                        
        let email: string | undefined;                                                                                                               
        let url: string | undefined;                                                                                                                 
                                                                                                                                                     
        if (inputData.contactId) {                                                                                                                   
          const contactIdInput = inputData.contactId;                                                                                                
          const configuredContacts = agent.crm_ghost_config?.contacts || [];                                                                         
          const searchTerm = normalizeForSearch(contactIdInput);                                                                                     
                                                                                                                                                     
          let contact = configuredContacts.find(c => {                                                                                               
            if (c.id && c.id.toLowerCase() === contactIdInput.toLowerCase()) return true;                                                            
            const contactName = c.fullName || c.name || '';                                                                                          
            if (contactName.toLowerCase() === contactIdInput.toLowerCase()) return true;                                                             
            if (normalizeForSearch(contactName).includes(searchTerm)) return true;                                                                   
            return false;                                                                                                                            
          });                                                                                                                                        
                                                                                                                                                     
          if (!contact) {                                                                                                                            
            const availableContacts = configuredContacts.map(c => {                                                                                  
              const name = c.fullName || c.name || 'Sem nome';                                                                                       
              const id = c.id || 'auto';                                                                                                             
              return `${name} (id: ${id})`;                                                                                                          
            }).join(', ') || 'nenhum';                                                                                                               
            return { success: false, message: `Contato "${contactIdInput}" não encontrado. Disponíveis: ${availableContacts}`, nextAction: 'continue'
   };                                                                                                                                                
          }                                                                                                                                          
                                                                                                                                                     
          fullName = contact.fullName || contact.name || '';                                                                                         
          const rawPhone = contact.phoneNumber || contact.phone || '';                                                                               
  ⎿ API Error: Claude's response exceeded the 32000 output token maximum. To configure this behavior, set the CLAUDE_CODE_MAX_OUTPUT_TOKENS          
    environment variable.                                                                                                                            
                                                                                                                                                     
● Continuando de onde parei...                                                                                                                       
                                                                                                                                                     
  ---                                                                                                                                                
  Parte 24 (continuação): tools/send-contact.tool.ts                                                                                                 
                                                                                                                                                     
          organization = contact.organization;                                                                                                       
          email = contact.email;                                                                                                                     
          url = contact.url;                                                                                                                         
                                                                                                                                                     
          if (!fullName || !rawPhone) {                                                                                                              
            return { success: false, message: `Contato "${contactIdInput}" incompleto (falta nome ou telefone)`, nextAction: 'continue' };           
          }                                                                                                                                          
                                                                                                                                                     
          if (!isValidPhoneNumber(rawPhone)) {                                                                                                       
            return { success: false, message: `Contato "${contactIdInput}" tem telefone inválido: "${rawPhone}"`, nextAction: 'continue' };          
          }                                                                                                                                          
          phoneNumber = cleanPhoneNumber(rawPhone);                                                                                                  
        } else {                                                                                                                                     
          if (!inputData.fullName || !inputData.phoneNumber) {                                                                                       
            return { success: false, message: 'Informe contactId OU (fullName + phoneNumber)', nextAction: 'continue' };                             
          }                                                                                                                                          
          fullName = inputData.fullName;                                                                                                             
          phoneNumber = cleanPhoneNumber(inputData.phoneNumber);                                                                                     
          organization = inputData.organization;                                                                                                     
          email = inputData.email;                                                                                                                   
          url = inputData.url;                                                                                                                       
        }                                                                                                                                            
                                                                                                                                                     
        const uazapiClient = new UazapiClient({ baseUrl: agent.uazapi_base_url, instanceToken: agent.uazapi_token });                                
        await uazapiClient.sendContact(context.remoteJid, fullName, phoneNumber, { organization, email, url });                                      
                                                                                                                                                     
        return {                                                                                                                                     
          success: true,                                                                                                                             
          message: `Cartão de contato enviado: ${fullName}`,                                                                                         
          data: { fullName, phoneNumber, organization, email, url, contactSent: true },                                                              
          nextAction: 'respond',                                                                                                                     
        };                                                                                                                                           
      } catch (error) {                                                                                                                              
        return { success: false, message: `Erro: ${error instanceof Error ? error.message : 'Erro'}`, nextAction: 'continue' };                      
      }                                                                                                                                              
    },                                                                                                                                               
  };      